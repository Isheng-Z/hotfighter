import { Difficulty, Question } from './types';

export const INITIAL_QUESTIONS: Question[] = [
  // --- EASY ---
  {
    id: 1,
    title: "Two Sum",
    titleCn: "两数之和",
    slug: "two-sum",
    difficulty: Difficulty.Easy,
    tags: ["Array", "Hash Table"],
    description: "Find two numbers in an array that add up to a specific target.",
    descriptionCn: "在数组中找到两个数，使它们的和等于目标值。",
    solutionIdea: "Use a Hash Map to store (target - current_value) as key and index as value. Iterate once.",
    solutionIdeaCn: "使用哈希表。遍历数组，对于每个数 x，检查 target - x 是否在哈希表中。如果在，返回它们的索引；如果不在，将 x 及其索引存入哈希表。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [2,7,11,15], target = 9",
    exampleOutput: "[0,1]"
  },
  {
    id: 10,
    title: "Regular Expression Matching",
    titleCn: "正则表达式匹配",
    slug: "regular-expression-matching",
    difficulty: Difficulty.Hard,
    tags: ["DP", "Recursion"],
    description: "Implement regex matching with '.' and '*'.",
    descriptionCn: "实现支持 '.' 和 '*' 的正则表达式匹配。",
    solutionIdea: "DP. dp[i][j] depends on p[j-1]. If '*', check zero or more matches.",
    solutionIdeaCn: "动态规划。dp[i][j] 表示 s[:i] 和 p[:j] 是否匹配。重点处理 '*' 的情况（匹配 0 次或多次）。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(mn)",
    exampleInput: "s = \"aa\", p = \"a*\"",
    exampleOutput: "true"
  },
  {
    id: 20,
    title: "Valid Parentheses",
    titleCn: "有效的括号",
    slug: "valid-parentheses",
    difficulty: Difficulty.Easy,
    tags: ["String", "Stack"],
    description: "Determine if input string of brackets is valid.",
    descriptionCn: "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。",
    solutionIdea: "Stack. Push opening brackets. When closing bracket encountered, check if stack top matches.",
    solutionIdeaCn: "栈。遇到左括号入栈。遇到右括号，检查栈顶是否是对应的左括号，若是则出栈，否则无效。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \"()[]{}\"",
    exampleOutput: "true"
  },
  {
    id: 21,
    title: "Merge Two Sorted Lists",
    titleCn: "合并两个有序链表",
    slug: "merge-two-sorted-lists",
    difficulty: Difficulty.Easy,
    tags: ["Linked List", "Recursion"],
    description: "Merge two sorted linked lists into one sorted list.",
    descriptionCn: "将两个升序链表合并为一个新的 升序 链表并返回。",
    solutionIdea: "Dummy head + Iteration. Compare heads of l1 and l2, attach smaller to current.",
    solutionIdeaCn: "迭代法：使用哨兵节点 (dummy node)。比较 l1 和 l2 的值，将较小的节点接到 current 后面。",
    timeComplexity: "O(n + m)",
    spaceComplexity: "O(1)",
    exampleInput: "l1 = [1,2,4], l2 = [1,3,4]",
    exampleOutput: "[1,1,2,3,4,4]"
  },
  {
    id: 70,
    title: "Climbing Stairs",
    titleCn: "爬楼梯",
    slug: "climbing-stairs",
    difficulty: Difficulty.Easy,
    tags: ["DP", "Math"],
    description: "Count distinct ways to climb n stairs taking 1 or 2 steps.",
    descriptionCn: "假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。有多少种不同的方法？",
    solutionIdea: "Fibonacci. ways(n) = ways(n-1) + ways(n-2).",
    solutionIdeaCn: "斐波那契数列。f(n) = f(n-1) + f(n-2)。使用滚动数组优化空间。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "n = 3",
    exampleOutput: "3"
  },
  {
    id: 88,
    title: "Merge Sorted Array",
    titleCn: "合并两个有序数组",
    slug: "merge-sorted-array",
    difficulty: Difficulty.Easy,
    tags: ["Array", "Two Pointers"],
    description: "Merge nums2 into nums1 as one sorted array.",
    descriptionCn: "合并两个有序数组到 nums1 中。",
    solutionIdea: "Three Pointers. Fill from the end (largest elements) to start.",
    solutionIdeaCn: "三指针 / 逆向双指针。从后往前填充 nums1，避免覆盖未处理元素。",
    timeComplexity: "O(m+n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums1 = [1,2,3,0,0,0], nums2 = [2,5,6]",
    exampleOutput: "[1,2,2,3,5,6]"
  },
  {
    id: 94,
    title: "Binary Tree Inorder Traversal",
    titleCn: "二叉树的中序遍历",
    slug: "binary-tree-inorder-traversal",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS", "Stack"],
    description: "Return inorder traversal of binary tree nodes.",
    descriptionCn: "给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。",
    solutionIdea: "Recursion or Stack. Left -> Root -> Right.",
    solutionIdeaCn: "递归：dfs(left) -> print(val) -> dfs(right)。迭代：用栈模拟递归。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,null,2,3]",
    exampleOutput: "[1,3,2]"
  },
  {
    id: 101,
    title: "Symmetric Tree",
    titleCn: "对称二叉树",
    slug: "symmetric-tree",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS", "BFS"],
    description: "Check if tree is mirror of itself.",
    descriptionCn: "给你一个二叉树的根节点 root ， 检查它是否轴对称。",
    solutionIdea: "Recursion. isMirror(t1, t2): t1.val == t2.val && isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left).",
    solutionIdeaCn: "递归：check(p, q)。p.val == q.val 且 check(p.left, q.right) 且 check(p.right, q.left)。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,2,2,3,4,4,3]",
    exampleOutput: "true"
  },
  {
    id: 104,
    title: "Maximum Depth of Binary Tree",
    titleCn: "二叉树的最大深度",
    slug: "maximum-depth-of-binary-tree",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS"],
    description: "Find max depth.",
    descriptionCn: "给定一个二叉树，找出其最大深度。",
    solutionIdea: "Recursion: max(depth(left), depth(right)) + 1.",
    solutionIdeaCn: "递归：1 + max(maxDepth(left), maxDepth(right))。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [3,9,20,null,null,15,7]",
    exampleOutput: "3"
  },
  {
    id: 121,
    title: "Best Time to Buy and Sell Stock",
    titleCn: "买卖股票的最佳时机",
    slug: "best-time-to-buy-and-sell-stock",
    difficulty: Difficulty.Easy,
    tags: ["Array", "DP"],
    description: "Maximize profit by buying once and selling once.",
    descriptionCn: "给定一个数组 prices ，求只做一次交易（买入和卖出）的最大利润。",
    solutionIdea: "One Pass. Maintain 'min_price'. Profit = price - min_price.",
    solutionIdeaCn: "一次遍历。维护 min_price。每天计算 (price - min_price)，更新最大利润。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "prices = [7,1,5,3,6,4]",
    exampleOutput: "5"
  },
  {
    id: 136,
    title: "Single Number",
    titleCn: "只出现一次的数字",
    slug: "single-number",
    difficulty: Difficulty.Easy,
    tags: ["Bit Manipulation"],
    description: "Find the element that appears once, others appear twice.",
    descriptionCn: "给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。",
    solutionIdea: "XOR all numbers. A ^ A = 0, A ^ 0 = A.",
    solutionIdeaCn: "异或运算。a ^ a = 0, a ^ 0 = a。全部异或得到结果。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [4,1,2,1,2]",
    exampleOutput: "4"
  },
  {
    id: 141,
    title: "Linked List Cycle",
    titleCn: "环形链表",
    slug: "linked-list-cycle",
    difficulty: Difficulty.Easy,
    tags: ["Linked List", "Two Pointers"],
    description: "Determine if linked list has a cycle.",
    descriptionCn: "判断链表中是否有环。",
    solutionIdea: "Fast/Slow Pointers. If they meet, cycle exists.",
    solutionIdeaCn: "快慢指针。快走2步，慢走1步。若相遇则有环。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [3,2,0,-4], pos = 1",
    exampleOutput: "true"
  },
  {
    id: 160,
    title: "Intersection of Two Linked Lists",
    titleCn: "相交链表",
    slug: "intersection-of-two-linked-lists",
    difficulty: Difficulty.Easy,
    tags: ["Linked List", "Two Pointers"],
    description: "Find node where two lists intersect.",
    descriptionCn: "找出两个单链表相交的起始节点。",
    solutionIdea: "Two Pointers. Iterate A then B. Iterate B then A. Meet at intersection.",
    solutionIdeaCn: "双指针。A 走完走 B，B 走完走 A。消除长度差后在交点相遇。",
    timeComplexity: "O(n+m)",
    spaceComplexity: "O(1)",
    exampleInput: "listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]",
    exampleOutput: "Node 8"
  },
  {
    id: 169,
    title: "Majority Element",
    titleCn: "多数元素",
    slug: "majority-element",
    difficulty: Difficulty.Easy,
    tags: ["Array", "Divide and Conquer"],
    description: "Find element appearing > n/2 times.",
    descriptionCn: "找到出现次数大于 n/2 的元素。",
    solutionIdea: "Boyer-Moore Voting. Count++, Count-- if different.",
    solutionIdeaCn: "摩尔投票法。相同加票，不同减票。最后剩下的就是众数。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,2,1,1,1,2,2]",
    exampleOutput: "2"
  },
  {
    id: 206,
    title: "Reverse Linked List",
    titleCn: "反转链表",
    slug: "reverse-linked-list",
    difficulty: Difficulty.Easy,
    tags: ["Linked List"],
    description: "Reverse a singly linked list.",
    descriptionCn: "反转单链表。",
    solutionIdea: "Iterative. prev = null, curr = head. Swap next pointers.",
    solutionIdeaCn: "迭代。prev 指向 null，curr 指向 head。保存 next，改变指向，前移。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [1,2,3,4,5]",
    exampleOutput: "[5,4,3,2,1]"
  },
  {
    id: 226,
    title: "Invert Binary Tree",
    titleCn: "翻转二叉树",
    slug: "invert-binary-tree",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS"],
    description: "Invert left and right children.",
    descriptionCn: "翻转二叉树的左右子树。",
    solutionIdea: "Recursion. Swap left and right. Recurse.",
    solutionIdeaCn: "递归。交换左右子节点，然后递归处理左右子树。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [4,2,7,1,3]",
    exampleOutput: "[4,7,2,3,1]"
  },
  {
    id: 234,
    title: "Palindrome Linked List",
    titleCn: "回文链表",
    slug: "palindrome-linked-list",
    difficulty: Difficulty.Easy,
    tags: ["Linked List", "Two Pointers"],
    description: "Check if linked list is palindrome.",
    descriptionCn: "判断链表是否是回文结构。",
    solutionIdea: "Find middle, reverse second half, compare.",
    solutionIdeaCn: "快慢指针找中点，反转后半部分链表，然后双指针比较前后两部分。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [1,2,2,1]",
    exampleOutput: "true"
  },
  {
    id: 283,
    title: "Move Zeroes",
    titleCn: "移动零",
    slug: "move-zeroes",
    difficulty: Difficulty.Easy,
    tags: ["Array", "Two Pointers"],
    description: "Move zeroes to end, keep order.",
    descriptionCn: "将所有 0 移动到末尾，保持非零元素相对顺序。",
    solutionIdea: "Two Pointers. Swap non-zero to insert pos.",
    solutionIdeaCn: "双指针。Left 指向放置位置，Right 遍历。遇非零交换并移动 Left。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [0,1,0,3,12]",
    exampleOutput: "[1,3,12,0,0]"
  },
  {
    id: 338,
    title: "Counting Bits",
    titleCn: "比特位计数",
    slug: "counting-bits",
    difficulty: Difficulty.Easy,
    tags: ["DP", "Bit Manipulation"],
    description: "Count set bits for 0 to n.",
    descriptionCn: "计算 0 到 n 每个数的二进制中 1 的个数。",
    solutionIdea: "DP. dp[i] = dp[i >> 1] + (i & 1).",
    solutionIdeaCn: "动态规划。i 的 1 个数等于 i/2 的 1 个数加上 i 是否为奇数。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "n = 2",
    exampleOutput: "[0,1,1]"
  },
  {
    id: 448,
    title: "Find All Numbers Disappeared in an Array",
    titleCn: "找到所有数组中消失的数字",
    slug: "find-all-numbers-disappeared-in-an-array",
    difficulty: Difficulty.Easy,
    tags: ["Array"],
    description: "Find numbers 1..n missing from array.",
    descriptionCn: "找到 1 到 n 中没有出现在数组中的数字。",
    solutionIdea: "Mark index. Iterate x, set nums[|x|-1] negative. Positive indices are missing.",
    solutionIdeaCn: "原地哈希。遍历数组，将元素 x 对应的索引 abs(x)-1 处的值置为负数。最后为正数的索引+1即为缺失值。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [4,3,2,7,8,2,3,1]",
    exampleOutput: "[5,6]"
  },
  {
    id: 461,
    title: "Hamming Distance",
    titleCn: "汉明距离",
    slug: "hamming-distance",
    difficulty: Difficulty.Easy,
    tags: ["Bit Manipulation"],
    description: "Distance between bits of two integers.",
    descriptionCn: "两个整数二进制位不同的位置数目。",
    solutionIdea: "XOR then count bits.",
    solutionIdeaCn: "异或后计算 1 的个数。",
    timeComplexity: "O(1)",
    spaceComplexity: "O(1)",
    exampleInput: "x = 1, y = 4",
    exampleOutput: "2"
  },
  {
    id: 543,
    title: "Diameter of Binary Tree",
    titleCn: "二叉树的直径",
    slug: "diameter-of-binary-tree",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS"],
    description: "Longest path between any two nodes.",
    descriptionCn: "任意两个节点间最长路径的长度。",
    solutionIdea: "DFS. Max(left_depth + right_depth). Update global max during recursion.",
    solutionIdeaCn: "深度优先搜索。对每个节点，计算左子树深度+右子树深度，更新全局最大值。返回该节点深度。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,2,3,4,5]",
    exampleOutput: "3"
  },
  {
    id: 617,
    title: "Merge Two Binary Trees",
    titleCn: "合并二叉树",
    slug: "merge-two-binary-trees",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS"],
    description: "Merge overlapping nodes by summing values.",
    descriptionCn: "合并两棵二叉树，重叠节点值相加。",
    solutionIdea: "Recursion. New node val = t1.val + t2.val. Recurse children.",
    solutionIdeaCn: "递归。新节点值 = t1 + t2。递归合并左右子树。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]",
    exampleOutput: "[3,4,5,5,4,null,7]"
  },

  // --- MEDIUM ---
  {
    id: 2,
    title: "Add Two Numbers",
    titleCn: "两数相加",
    slug: "add-two-numbers",
    difficulty: Difficulty.Medium,
    tags: ["Linked List", "Math"],
    description: "Add two non-negative integers represented by linked lists.",
    descriptionCn: "逆序链表表示的两个数相加。",
    solutionIdea: "Iterate, maintain carry. (val1 + val2 + carry) % 10.",
    solutionIdeaCn: "遍历链表，维护进位 carry。新节点值为 (n1 + n2 + carry) % 10。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "l1 = [2,4,3], l2 = [5,6,4]",
    exampleOutput: "[7,0,8]"
  },
  {
    id: 3,
    title: "Longest Substring Without Repeating Characters",
    titleCn: "无重复字符的最长子串",
    slug: "longest-substring-without-repeating-characters",
    difficulty: Difficulty.Medium,
    tags: ["Sliding Window", "Hash Table"],
    description: "Find length of longest substring with unique chars.",
    descriptionCn: "不含重复字符的最长子串长度。",
    solutionIdea: "Sliding Window + Map. If repeat, move left to prev_index + 1.",
    solutionIdeaCn: "滑动窗口。Map 记录字符位置。遇重复字符更新左边界。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"abcabcbb\"",
    exampleOutput: "3"
  },
  {
    id: 5,
    title: "Longest Palindromic Substring",
    titleCn: "最长回文子串",
    slug: "longest-palindromic-substring",
    difficulty: Difficulty.Medium,
    tags: ["DP", "String"],
    description: "Find longest palindrome.",
    descriptionCn: "找到最长的回文子串。",
    solutionIdea: "Center Expansion. Expand from each char and gap.",
    solutionIdeaCn: "中心扩散法。以每个字符或间隙为中心向两边扩散。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"babad\"",
    exampleOutput: "\"bab\""
  },
  {
    id: 11,
    title: "Container With Most Water",
    titleCn: "盛最多水的容器",
    slug: "container-with-most-water",
    difficulty: Difficulty.Medium,
    tags: ["Two Pointers"],
    description: "Find max area between two lines.",
    descriptionCn: "找出两条线使容器容纳最多的水。",
    solutionIdea: "Two Pointers. Move shorter line inward.",
    solutionIdeaCn: "双指针。向内移动较短的板子，试图找到更高板子。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "height = [1,8,6,2,5,4,8,3,7]",
    exampleOutput: "49"
  },
  {
    id: 15,
    title: "3Sum",
    titleCn: "三数之和",
    slug: "3sum",
    difficulty: Difficulty.Medium,
    tags: ["Two Pointers", "Sorting"],
    description: "Unique triplets sum to zero.",
    descriptionCn: "和为 0 的不重复三元组。",
    solutionIdea: "Sort + Two Pointers. Fix i, find 2sum using left/right.",
    solutionIdeaCn: "排序。遍历 i，双指针找两数之和等于 -nums[i]。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [-1,0,1,2,-1,-4]",
    exampleOutput: "[[-1,-1,2],[-1,0,1]]"
  },
  {
    id: 17,
    title: "Letter Combinations of a Phone Number",
    titleCn: "电话号码的字母组合",
    slug: "letter-combinations-of-a-phone-number",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "Possible letter combinations from digits.",
    descriptionCn: "数字对应的所有字母组合。",
    solutionIdea: "Backtracking. Loop letters for current digit, recurse.",
    solutionIdeaCn: "回溯。遍历当前数字对应的字母，递归拼接。",
    timeComplexity: "O(4^n)",
    spaceComplexity: "O(n)",
    exampleInput: "digits = \"23\"",
    exampleOutput: "[\"ad\",\"ae\",\"af\",...]"
  },
  {
    id: 19,
    title: "Remove Nth Node From End of List",
    titleCn: "删除链表的倒数第 N 个结点",
    slug: "remove-nth-node-from-end-of-list",
    difficulty: Difficulty.Medium,
    tags: ["Linked List", "Two Pointers"],
    description: "Remove nth from end.",
    descriptionCn: "删除倒数第 n 个节点。",
    solutionIdea: "Fast pointer ahead by n. Then move both.",
    solutionIdeaCn: "快指针先走 n 步，然后快慢同走直到快指针到头。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [1,2,3,4,5], n = 2",
    exampleOutput: "[1,2,3,5]"
  },
  {
    id: 22,
    title: "Generate Parentheses",
    titleCn: "括号生成",
    slug: "generate-parentheses",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "Generate all valid parentheses.",
    descriptionCn: "生成所有有效的括号组合。",
    solutionIdea: "Backtrack. Add '(' if open < n. Add ')' if close < open.",
    solutionIdeaCn: "回溯。控制左括号和右括号的数量。左 < n 可加左，右 < 左 可加右。",
    timeComplexity: "O(4^n/sqrt(n))",
    spaceComplexity: "O(n)",
    exampleInput: "n = 3",
    exampleOutput: "[\"((()))\",...]"
  },
  {
    id: 31,
    title: "Next Permutation",
    titleCn: "下一个排列",
    slug: "next-permutation",
    difficulty: Difficulty.Medium,
    tags: ["Array"],
    description: "Find next lexicographical permutation.",
    descriptionCn: "找到字典序的下一个排列。",
    solutionIdea: "Find first decrease from right, swap with larger, reverse rest.",
    solutionIdeaCn: "从右找第一个降序数，找比它大的最小数交换，反转后缀。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [1,2,3]",
    exampleOutput: "[1,3,2]"
  },
  {
    id: 33,
    title: "Search in Rotated Sorted Array",
    titleCn: "搜索旋转排序数组",
    slug: "search-in-rotated-sorted-array",
    difficulty: Difficulty.Medium,
    tags: ["Binary Search"],
    description: "Search in rotated array O(log n).",
    descriptionCn: "在旋转排序数组中查找。",
    solutionIdea: "Binary Search. Determine which half is sorted.",
    solutionIdeaCn: "二分查找。判断哪一半有序，检查 target 是否在有序区间。",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [4,5,6,7,0,1,2], target = 0",
    exampleOutput: "4"
  },
  {
    id: 34,
    title: "Find First and Last Position",
    titleCn: "在排序数组中查找元素的第一个和最后一个位置",
    slug: "find-first-and-last-position-of-element-in-sorted-array",
    difficulty: Difficulty.Medium,
    tags: ["Binary Search"],
    description: "Start and end index of target.",
    descriptionCn: "查找目标值的起始和结束位置。",
    solutionIdea: "Two Binary Searches. Lower bound and Upper bound.",
    solutionIdeaCn: "两次二分，分别找左边界和右边界。",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [5,7,7,8,8,10], target = 8",
    exampleOutput: "[3,4]"
  },
  {
    id: 39,
    title: "Combination Sum",
    titleCn: "组合总和",
    slug: "combination-sum",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "Combinations summing to target (reuse allowed).",
    descriptionCn: "数字和为目标值的组合（可重复使用）。",
    solutionIdea: "Backtracking. Reuse index i in recursion.",
    solutionIdeaCn: "回溯。递归时索引 i 不变（允许重复），target 减去当前值。",
    timeComplexity: "O(S)",
    spaceComplexity: "O(target)",
    exampleInput: "candidates = [2,3,6,7], target = 7",
    exampleOutput: "[[2,2,3],[7]]"
  },
  {
    id: 46,
    title: "Permutations",
    titleCn: "全排列",
    slug: "permutations",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "All possible permutations.",
    descriptionCn: "所有可能的排列。",
    solutionIdea: "Backtracking. Swap or Visited array.",
    solutionIdeaCn: "回溯。标记 visited 或交换元素。",
    timeComplexity: "O(n*n!)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [1,2,3]",
    exampleOutput: "[[1,2,3],...]"
  },
  {
    id: 48,
    title: "Rotate Image",
    titleCn: "旋转图像",
    slug: "rotate-image",
    difficulty: Difficulty.Medium,
    tags: ["Matrix"],
    description: "Rotate matrix 90 deg clockwise.",
    descriptionCn: "顺时针旋转矩阵 90 度。",
    solutionIdea: "Transpose + Reverse Rows.",
    solutionIdeaCn: "先转置（对角线翻转），再左右翻转（每行逆序）。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(1)",
    exampleInput: "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
    exampleOutput: "[[7,4,1],[8,5,2],[9,6,3]]"
  },
  {
    id: 49,
    title: "Group Anagrams",
    titleCn: "字母异位词分组",
    slug: "group-anagrams",
    difficulty: Difficulty.Medium,
    tags: ["Hash Table"],
    description: "Group anagrams together.",
    descriptionCn: "将字母异位词组合在一起。",
    solutionIdea: "Hash Map. Key = Sorted String or Count Array.",
    solutionIdeaCn: "哈希表。键为排序后的字符串或字符计数数组。",
    timeComplexity: "O(nk log k)",
    spaceComplexity: "O(nk)",
    exampleInput: "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
    exampleOutput: "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
  },
  {
    id: 53,
    title: "Maximum Subarray",
    titleCn: "最大子数组和",
    slug: "maximum-subarray",
    difficulty: Difficulty.Medium,
    tags: ["DP", "Array"],
    description: "Largest sum contiguous subarray.",
    descriptionCn: "和最大的连续子数组。",
    solutionIdea: "Kadane's Algo. max_so_far = max(num, max_so_far + num).",
    solutionIdeaCn: "贪心/DP。若前缀和 < 0 则丢弃，重新开始计算。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [-2,1,-3,4,-1,2,1,-5,4]",
    exampleOutput: "6"
  },
  {
    id: 55,
    title: "Jump Game",
    titleCn: "跳跃游戏",
    slug: "jump-game",
    difficulty: Difficulty.Medium,
    tags: ["Greedy"],
    description: "Can you reach the last index?",
    descriptionCn: "能否到达最后一个下标。",
    solutionIdea: "Greedy. Update max reachable index.",
    solutionIdeaCn: "贪心。维护能到达的最远位置。若当前位置 > 最远位置则无法到达。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,3,1,1,4]",
    exampleOutput: "true"
  },
  {
    id: 56,
    title: "Merge Intervals",
    titleCn: "合并区间",
    slug: "merge-intervals",
    difficulty: Difficulty.Medium,
    tags: ["Sorting", "Array"],
    description: "Merge overlapping intervals.",
    descriptionCn: "合并重叠区间。",
    solutionIdea: "Sort by start. If curr.start <= prev.end, merge.",
    solutionIdeaCn: "按起点排序。若当前起点 <= 上个终点，合并（更新终点）。",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(n)",
    exampleInput: "intervals = [[1,3],[2,6],[8,10]]",
    exampleOutput: "[[1,6],[8,10]]"
  },
  {
    id: 62,
    title: "Unique Paths",
    titleCn: "不同路径",
    slug: "unique-paths",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Paths from top-left to bottom-right.",
    descriptionCn: "从左上角到右下角的路径数。",
    solutionIdea: "DP. dp[i][j] = dp[i-1][j] + dp[i][j-1].",
    solutionIdeaCn: "动态规划。格子路径数 = 上方格子数 + 左方格子数。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(n)",
    exampleInput: "m = 3, n = 7",
    exampleOutput: "28"
  },
  {
    id: 64,
    title: "Minimum Path Sum",
    titleCn: "最小路径和",
    slug: "minimum-path-sum",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Min sum path top-left to bottom-right.",
    descriptionCn: "路径数字总和最小。",
    solutionIdea: "DP. dp[i][j] = val + min(up, left).",
    solutionIdeaCn: "动态规划。当前值 + min(上, 左)。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(1)",
    exampleInput: "grid = [[1,3,1],[1,5,1],[4,2,1]]",
    exampleOutput: "7"
  },
  {
    id: 75,
    title: "Sort Colors",
    titleCn: "颜色分类",
    slug: "sort-colors",
    difficulty: Difficulty.Medium,
    tags: ["Two Pointers", "Sorting"],
    description: "Sort 0, 1, 2 in-place.",
    descriptionCn: "原地排序 0, 1, 2。",
    solutionIdea: "3 Pointers (Dutch Flag). p0, curr, p2.",
    solutionIdeaCn: "三指针。0 换到头，2 换到尾，1 跳过。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,0,2,1,1,0]",
    exampleOutput: "[0,0,1,1,2,2]"
  },
  {
    id: 78,
    title: "Subsets",
    titleCn: "子集",
    slug: "subsets",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "All possible subsets (power set).",
    descriptionCn: "所有可能的子集。",
    solutionIdea: "Backtracking or Cascading.",
    solutionIdeaCn: "回溯。选或不选当前元素。",
    timeComplexity: "O(n*2^n)",
    spaceComplexity: "O(n*2^n)",
    exampleInput: "nums = [1,2,3]",
    exampleOutput: "[[],[1],[2],[1,2]...]"
  },
  {
    id: 79,
    title: "Word Search",
    titleCn: "单词搜索",
    slug: "word-search",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking", "Matrix"],
    description: "Exist word in grid?",
    descriptionCn: "网格中是否存在单词。",
    solutionIdea: "DFS/Backtracking. Mark visited.",
    solutionIdeaCn: "DFS 回溯。遍历起点，搜索四个方向，标记已访问。",
    timeComplexity: "O(mn*3^L)",
    spaceComplexity: "O(L)",
    exampleInput: "board = ... word = \"ABCCED\"",
    exampleOutput: "true"
  },
  {
    id: 96,
    title: "Unique BSTs",
    titleCn: "不同的二叉搜索树",
    slug: "unique-binary-search-trees",
    difficulty: Difficulty.Medium,
    tags: ["DP", "Tree"],
    description: "Count unique BSTs with n nodes.",
    descriptionCn: "n 个节点组成的互不相同的 BST 种数。",
    solutionIdea: "DP (Catalan). sum(dp[i-1] * dp[n-i]).",
    solutionIdeaCn: "卡特兰数。左子树个数 * 右子树个数，累加所有根的情况。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(n)",
    exampleInput: "n = 3",
    exampleOutput: "5"
  },
  {
    id: 98,
    title: "Validate Binary Search Tree",
    titleCn: "验证二叉搜索树",
    slug: "validate-binary-search-tree",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Check if valid BST.",
    descriptionCn: "判断是否是有效 BST。",
    solutionIdea: "Recursion with range (min, max).",
    solutionIdeaCn: "递归带范围。左子树 < root < 右子树。或中序遍历严格递增。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [2,1,3]",
    exampleOutput: "true"
  },
  {
    id: 102,
    title: "Binary Tree Level Order Traversal",
    titleCn: "二叉树的层序遍历",
    slug: "binary-tree-level-order-traversal",
    difficulty: Difficulty.Medium,
    tags: ["BFS", "Tree"],
    description: "Level by level traversal.",
    descriptionCn: "层序遍历。",
    solutionIdea: "BFS Queue. Process current level size.",
    solutionIdeaCn: "BFS 队列。每次处理当前队列长度的所有节点（一层）。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [3,9,20...]",
    exampleOutput: "[[3],[9,20]...]"
  },
  {
    id: 105,
    title: "Construct Tree from Pre/Inorder",
    titleCn: "从前序与中序遍历构造二叉树",
    slug: "construct-binary-tree-from-preorder-and-inorder-traversal",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "Recursion"],
    description: "Build tree from traversals.",
    descriptionCn: "根据前序和中序构造二叉树。",
    solutionIdea: "Preorder root. Find in Inorder. Split left/right.",
    solutionIdeaCn: "前序定根，中序定左右。递归构建。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "pre = [3,9,20,15,7], in = [9,3,15,20,7]",
    exampleOutput: "[3,9,20...]"
  },
  {
    id: 114,
    title: "Flatten Binary Tree to Linked List",
    titleCn: "二叉树展开为链表",
    slug: "flatten-binary-tree-to-linked-list",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Flatten to right-skewed list in-place.",
    descriptionCn: "原地展开为单链表。",
    solutionIdea: "Post-order (Right, Left, Root) or Morris.",
    solutionIdeaCn: "变形后序（右左根），prev 记录上个节点。或找左子树最右节点挂载。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,2,5...]",
    exampleOutput: "[1,null,2...]"
  },
  {
    id: 128,
    title: "Longest Consecutive Sequence",
    titleCn: "最长连续序列",
    slug: "longest-consecutive-sequence",
    difficulty: Difficulty.Medium,
    tags: ["Hash Table"],
    description: "Longest consecutive elements sequence O(n).",
    descriptionCn: "最长数字连续序列长度，要求 O(n)。",
    solutionIdea: "Set. If num-1 not in set, start counting num+1.",
    solutionIdeaCn: "哈希集合。只对序列起点 (num-1 不在集合) 开始向后数。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [100,4,200,1,3,2]",
    exampleOutput: "4"
  },
  {
    id: 139,
    title: "Word Break",
    titleCn: "单词拆分",
    slug: "word-break",
    difficulty: Difficulty.Medium,
    tags: ["DP", "String"],
    description: "Can string be segmented into dict words?",
    descriptionCn: "字符串能否被字典单词拆分。",
    solutionIdea: "DP. dp[i] = dp[j] && s[j:i] in dict.",
    solutionIdeaCn: "DP。dp[i] 表示前 i 个字符能被拆分。枚举分割点 j。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \"leetcode\", dict = [\"leet\",\"code\"]",
    exampleOutput: "true"
  },
  {
    id: 142,
    title: "Linked List Cycle II",
    titleCn: "环形链表 II",
    slug: "linked-list-cycle-ii",
    difficulty: Difficulty.Medium,
    tags: ["Linked List"],
    description: "Return node where cycle begins.",
    descriptionCn: "返回入环节点。",
    solutionIdea: "Fast/Slow meet. Move head and slow 1 step.",
    solutionIdeaCn: "相遇后，一个指针回头，同步走相遇即入口。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [3,2,0,-4]",
    exampleOutput: "node index 1"
  },
  {
    id: 146,
    title: "LRU Cache",
    titleCn: "LRU 缓存",
    slug: "lru-cache",
    difficulty: Difficulty.Medium,
    tags: ["Design"],
    description: "Least Recently Used cache.",
    descriptionCn: "设计 LRU 缓存。",
    solutionIdea: "Map + Doubly Linked List.",
    solutionIdeaCn: "哈希表 + 双向链表。Map 存节点，链表维护顺序。",
    timeComplexity: "O(1)",
    spaceComplexity: "O(capacity)",
    exampleInput: "put(1,1), put(2,2), get(1)...",
    exampleOutput: "..."
  },
  {
    id: 148,
    title: "Sort List",
    titleCn: "排序链表",
    slug: "sort-list",
    difficulty: Difficulty.Medium,
    tags: ["Linked List", "Sorting"],
    description: "Sort list O(n log n).",
    descriptionCn: "O(n log n) 排序链表。",
    solutionIdea: "Merge Sort. Split, Sort, Merge.",
    solutionIdeaCn: "归并排序。快慢指针找中点，递归排序，合并有序链表。",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(log n)",
    exampleInput: "head = [4,2,1,3]",
    exampleOutput: "[1,2,3,4]"
  },
  {
    id: 152,
    title: "Maximum Product Subarray",
    titleCn: "乘积最大子数组",
    slug: "maximum-product-subarray",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Subarray with largest product.",
    descriptionCn: "乘积最大的连续子数组。",
    solutionIdea: "DP. Track max and min (for negatives).",
    solutionIdeaCn: "维护最大值和最小值。遇负数交换极值。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,3,-2,4]",
    exampleOutput: "6"
  },
  {
    id: 155,
    title: "Min Stack",
    titleCn: "最小栈",
    slug: "min-stack",
    difficulty: Difficulty.Easy,
    tags: ["Stack"],
    description: "Stack with getMin O(1).",
    descriptionCn: "O(1) 获取最小值的栈。",
    solutionIdea: "Auxiliary Stack for minimums.",
    solutionIdeaCn: "辅助栈同步存当前最小值。",
    timeComplexity: "O(1)",
    spaceComplexity: "O(n)",
    exampleInput: "push(-2), push(0), push(-3), getMin()",
    exampleOutput: "-3"
  },
  {
    id: 198,
    title: "House Robber",
    titleCn: "打家劫舍",
    slug: "house-robber",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Max money without robbing adjacent.",
    descriptionCn: "偷钱不能连续偷相邻房屋。",
    solutionIdea: "DP. dp[i] = max(dp[i-1], dp[i-2] + nums[i]).",
    solutionIdeaCn: "DP。选当前：dp[i-2] + val；不选当前：dp[i-1]。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [1,2,3,1]",
    exampleOutput: "4"
  },
  {
    id: 200,
    title: "Number of Islands",
    titleCn: "岛屿数量",
    slug: "number-of-islands",
    difficulty: Difficulty.Medium,
    tags: ["DFS", "BFS"],
    description: "Count connected lands '1'.",
    descriptionCn: "计算岛屿数量。",
    solutionIdea: "DFS/BFS. Flood fill visited '1's to '0'.",
    solutionIdeaCn: "遍历，遇 1 启动 DFS 将相连的 1 沉岛（置 0）。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(mn)",
    exampleInput: "grid = [[\"1\",\"1\",\"0\"],[\"1\",\"0\",\"0\"]]",
    exampleOutput: "2"
  },
  {
    id: 207,
    title: "Course Schedule",
    titleCn: "课程表",
    slug: "course-schedule",
    difficulty: Difficulty.Medium,
    tags: ["Graph", "Topological Sort"],
    description: "Can finish courses with prerequisites?",
    descriptionCn: "是否有环。",
    solutionIdea: "Topological Sort (Indegree) or DFS cycle detect.",
    solutionIdeaCn: "拓扑排序。入度为 0 入队，减邻居入度。或 DFS 判环。",
    timeComplexity: "O(V+E)",
    spaceComplexity: "O(V+E)",
    exampleInput: "num = 2, pre = [[1,0]]",
    exampleOutput: "true"
  },
  {
    id: 208,
    title: "Implement Trie",
    titleCn: "实现 Trie (前缀树)",
    slug: "implement-trie-prefix-tree",
    difficulty: Difficulty.Medium,
    tags: ["Design", "Trie"],
    description: "Insert, search, startsWith.",
    descriptionCn: "实现前缀树。",
    solutionIdea: "Tree with children[26] and isEnd.",
    solutionIdeaCn: "多叉树。节点存子节点数组和结束标记。",
    timeComplexity: "O(L)",
    spaceComplexity: "O(L)",
    exampleInput: "insert(\"apple\"), search(\"apple\")",
    exampleOutput: "true"
  },
  {
    id: 215,
    title: "Kth Largest Element",
    titleCn: "数组中的第K个最大元素",
    slug: "kth-largest-element-in-an-array",
    difficulty: Difficulty.Medium,
    tags: ["Heap", "Quickselect"],
    description: "Find kth largest.",
    descriptionCn: "找第 K 大元素。",
    solutionIdea: "Min-Heap (size k) or Quickselect.",
    solutionIdeaCn: "最小堆存前 k 大。或快速选择（分区）。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [3,2,1,5,6,4], k = 2",
    exampleOutput: "5"
  },
  {
    id: 221,
    title: "Maximal Square",
    titleCn: "最大正方形",
    slug: "maximal-square",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Find largest square containing only 1s.",
    descriptionCn: "找到只包含 1 的最大正方形面积。",
    solutionIdea: "DP. dp[i][j] = min(up, left, diag) + 1.",
    solutionIdeaCn: "DP。当前边长 = min(上, 左, 左上) + 1。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(mn)",
    exampleInput: "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
    exampleOutput: "4"
  },
  {
    id: 236,
    title: "LCA of Binary Tree",
    titleCn: "二叉树的最近公共祖先",
    slug: "lowest-common-ancestor-of-a-binary-tree",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Lowest Common Ancestor of p and q.",
    descriptionCn: "最近公共祖先。",
    solutionIdea: "Recursion. If root is p or q return root. If left & right found, root is LCA.",
    solutionIdeaCn: "递归。若左右子树都有返回值，当前为 LCA。否则返回非空的一边。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [3,5,1...], p=5, q=1",
    exampleOutput: "3"
  },
  {
    id: 238,
    title: "Product of Array Except Self",
    titleCn: "除自身以外数组的乘积",
    slug: "product-of-array-except-self",
    difficulty: Difficulty.Medium,
    tags: ["Array"],
    description: "Product of all elements except self O(n) without division.",
    descriptionCn: "除自身外其他元素的乘积，不能用除法。",
    solutionIdea: "Prefix product * Suffix product.",
    solutionIdeaCn: "先算前缀积，再算后缀积，乘起来。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [1,2,3,4]",
    exampleOutput: "[24,12,8,6]"
  },
  {
    id: 240,
    title: "Search a 2D Matrix II",
    titleCn: "搜索二维矩阵 II",
    slug: "search-a-2d-matrix-ii",
    difficulty: Difficulty.Medium,
    tags: ["Array", "Divide and Conquer"],
    description: "Search in sorted rows/cols matrix.",
    descriptionCn: "行列递增矩阵中查找。",
    solutionIdea: "Start from top-right. < target down, > target left.",
    solutionIdeaCn: "从右上角开始。比 target 大往左，比 target 小往下。",
    timeComplexity: "O(m+n)",
    spaceComplexity: "O(1)",
    exampleInput: "matrix = [[1,4,7],[2,5,8]...], target = 5",
    exampleOutput: "true"
  },
  {
    id: 279,
    title: "Perfect Squares",
    titleCn: "完全平方数",
    slug: "perfect-squares",
    difficulty: Difficulty.Medium,
    tags: ["DP", "BFS"],
    description: "Least number of perfect squares summing to n.",
    descriptionCn: "和为 n 的最少完全平方数个数。",
    solutionIdea: "DP. dp[i] = min(dp[i - j*j]) + 1.",
    solutionIdeaCn: "DP。dp[i] = min(dp[i - j*j]) + 1。或 BFS。",
    timeComplexity: "O(n*sqrt(n))",
    spaceComplexity: "O(n)",
    exampleInput: "n = 12",
    exampleOutput: "3 (4+4+4)"
  },
  {
    id: 287,
    title: "Find the Duplicate Number",
    titleCn: "寻找重复数",
    slug: "find-the-duplicate-number",
    difficulty: Difficulty.Medium,
    tags: ["Array", "Two Pointers"],
    description: "Find duplicate in n+1 integers range 1-n.",
    descriptionCn: "n+1 个数里找重复数（范围 1-n）。",
    solutionIdea: "Floyd's Cycle Detection (Linked List cycle).",
    solutionIdeaCn: "快慢指针判环。视数值为 next 指针。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [1,3,4,2,2]",
    exampleOutput: "2"
  },
  {
    id: 300,
    title: "Longest Increasing Subsequence",
    titleCn: "最长递增子序列",
    slug: "longest-increasing-subsequence",
    difficulty: Difficulty.Medium,
    tags: ["DP", "Binary Search"],
    description: "Length of LIS.",
    descriptionCn: "最长严格递增子序列长度。",
    solutionIdea: "Patience Sorting (tails array + Binary Search).",
    solutionIdeaCn: "贪心 + 二分。维护 tails 数组，tails[i] 为长度 i+1 的 LIS 最小结尾。",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [10,9,2,5,3,7,101,18]",
    exampleOutput: "4"
  },
  {
    id: 309,
    title: "Best Time to Buy and Sell Stock with Cooldown",
    titleCn: "最佳买卖股票时机含冷冻期",
    slug: "best-time-to-buy-and-sell-stock-with-cooldown",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Max profit with 1 day cooldown after sell.",
    descriptionCn: "卖出后需冷冻一天。",
    solutionIdea: "DP State Machine (Hold, Sold, Rest).",
    solutionIdeaCn: "状态机 DP。持有、卖出（冷冻）、保持卖出。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "prices = [1,2,3,0,2]",
    exampleOutput: "3"
  },
  {
    id: 322,
    title: "Coin Change",
    titleCn: "零钱兑换",
    slug: "coin-change",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Fewest coins to make amount.",
    descriptionCn: "凑成金额的最少硬币数。",
    solutionIdea: "DP. dp[i] = min(dp[i], dp[i-coin] + 1).",
    solutionIdeaCn: "完全背包。dp[i] = min(dp[i - coin]) + 1。",
    timeComplexity: "O(Sn)",
    spaceComplexity: "O(S)",
    exampleInput: "coins = [1,2,5], amount = 11",
    exampleOutput: "3"
  },
  {
    id: 337,
    title: "House Robber III",
    titleCn: "打家劫舍 III",
    slug: "house-robber-iii",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DP"],
    description: "Rob binary tree houses, no direct links.",
    descriptionCn: "二叉树结构偷钱，不能偷相连父子。",
    solutionIdea: "Recursion returning [rob_root, not_rob_root].",
    solutionIdeaCn: "树形 DP。返回 [偷当前, 不偷当前]。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [3,2,3,null,3,null,1]",
    exampleOutput: "7"
  },
  {
    id: 347,
    title: "Top K Frequent Elements",
    titleCn: "前 K 个高频元素",
    slug: "top-k-frequent-elements",
    difficulty: Difficulty.Medium,
    tags: ["Heap"],
    description: "k most frequent elements.",
    descriptionCn: "频率前 k 高的元素。",
    solutionIdea: "Min-Heap or Bucket Sort.",
    solutionIdeaCn: "最小堆（大小k）或桶排序（频率为下标）。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [1,1,1,2,2,3], k = 2",
    exampleOutput: "[1,2]"
  },
  {
    id: 394,
    title: "Decode String",
    titleCn: "字符串解码",
    slug: "decode-string",
    difficulty: Difficulty.Medium,
    tags: ["Stack"],
    description: "Decode k[string] pattern.",
    descriptionCn: "解码 k[str] 模式。",
    solutionIdea: "Double Stack (count, string).",
    solutionIdeaCn: "双栈。数字栈存倍数，字符串栈存前缀。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \"3[a]2[bc]\"",
    exampleOutput: "\"aaabcbc\""
  },
  {
    id: 399,
    title: "Evaluate Division",
    titleCn: "除法求值",
    slug: "evaluate-division",
    difficulty: Difficulty.Medium,
    tags: ["Graph", "DFS", "Union Find"],
    description: "Graph division queries.",
    descriptionCn: "给定除法算式，求 query 结果。",
    solutionIdea: "Graph DFS/BFS. a/b=k means edge a->b weight k.",
    solutionIdeaCn: "建图。a->b 权值 k，b->a 权值 1/k。DFS 找路径乘积。",
    timeComplexity: "O(E+Q*V)",
    spaceComplexity: "O(V)",
    exampleInput: "calc a/c given a/b, b/c",
    exampleOutput: "..."
  },
  {
    id: 406,
    title: "Queue Reconstruction by Height",
    titleCn: "根据身高重建队列",
    slug: "queue-reconstruction-by-height",
    difficulty: Difficulty.Medium,
    tags: ["Greedy"],
    description: "Reconstruct queue (h, k).",
    descriptionCn: "根据 (身高, 前面更高人数) 重建队列。",
    solutionIdea: "Sort by height desc, k asc. Insert at k.",
    solutionIdeaCn: "按身高降序、k 升序排序。遍历插入 index = k。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(n)",
    exampleInput: "[[7,0],[4,4],[7,1]...]",
    exampleOutput: "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]"
  },
  {
    id: 416,
    title: "Partition Equal Subset Sum",
    titleCn: "分割等和子集",
    slug: "partition-equal-subset-sum",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Partition into two equal sum subsets.",
    descriptionCn: "分成和相等的两部分。",
    solutionIdea: "0/1 Knapsack. Target sum/2.",
    solutionIdeaCn: "0-1 背包。容量 sum/2 能否填满。",
    timeComplexity: "O(n*S)",
    spaceComplexity: "O(S)",
    exampleInput: "nums = [1,5,11,5]",
    exampleOutput: "true"
  },
  {
    id: 437,
    title: "Path Sum III",
    titleCn: "路径总和 III",
    slug: "path-sum-iii",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Count paths summing to target (downwards).",
    descriptionCn: "向下路径和为 target 的数量。",
    solutionIdea: "Prefix Sum Map + DFS.",
    solutionIdeaCn: "前缀和 + Map。currSum - target 是否存在。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [10,5,-3...], target = 8",
    exampleOutput: "3"
  },
  {
    id: 438,
    title: "Find All Anagrams",
    titleCn: "找到字符串中所有字母异位词",
    slug: "find-all-anagrams-in-a-string",
    difficulty: Difficulty.Medium,
    tags: ["Sliding Window"],
    description: "Start indices of anagrams of p in s.",
    descriptionCn: "找出 s 中 p 的所有异位词起始索引。",
    solutionIdea: "Sliding Window + Count Array.",
    solutionIdeaCn: "定长滑动窗口。维护字符计数比较。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"cbaebabacd\", p = \"abc\"",
    exampleOutput: "[0,6]"
  },
  {
    id: 494,
    title: "Target Sum",
    titleCn: "目标和",
    slug: "target-sum",
    difficulty: Difficulty.Medium,
    tags: ["DP", "DFS"],
    description: "Ways to assign +/- to sum to target.",
    descriptionCn: "添加正负号使和为 target 的方法数。",
    solutionIdea: "DP. Subset sum (P - N = T -> 2P = T + Sum).",
    solutionIdeaCn: "转换为子集和问题。找正数集和 P = (Sum + Target) / 2。",
    timeComplexity: "O(n*S)",
    spaceComplexity: "O(S)",
    exampleInput: "nums = [1,1,1,1,1], target = 3",
    exampleOutput: "5"
  },
  {
    id: 538,
    title: "Convert BST to Greater Tree",
    titleCn: "把二叉搜索树转换为累加树",
    slug: "convert-bst-to-greater-tree",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Add all greater values to node.",
    descriptionCn: "每个节点值加上所有大于它的节点值。",
    solutionIdea: "Reverse Inorder (Right, Root, Left). Accumulate sum.",
    solutionIdeaCn: "反向中序遍历（右根左）。累加 sum 并更新节点。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [4,1,6...]",
    exampleOutput: "[30,36,21...]"
  },
  {
    id: 560,
    title: "Subarray Sum Equals K",
    titleCn: "和为 K 的子数组",
    slug: "subarray-sum-equals-k",
    difficulty: Difficulty.Medium,
    tags: ["Prefix Sum"],
    description: "Count subarrays sum to k.",
    descriptionCn: "和为 K 的连续子数组个数。",
    solutionIdea: "Prefix Sum + Hash Map.",
    solutionIdeaCn: "前缀和 + Map。找 pre - k 出现的次数。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [1,1,1], k = 2",
    exampleOutput: "2"
  },
  {
    id: 581,
    title: "Shortest Unsorted Continuous Subarray",
    titleCn: "最短无序连续子数组",
    slug: "shortest-unsorted-continuous-subarray",
    difficulty: Difficulty.Medium,
    tags: ["Array"],
    description: "Shortest subarray to sort entire array.",
    descriptionCn: "最短需要排序的子数组。",
    solutionIdea: "Find first dip from left, first bump from right. Or Sort and Compare.",
    solutionIdeaCn: "排序比较。或一次遍历找 max 左边违规的右边界，min 右边违规的左边界。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,6,4,8,10,9,15]",
    exampleOutput: "5"
  },
  {
    id: 621,
    title: "Task Scheduler",
    titleCn: "任务调度器",
    slug: "task-scheduler",
    difficulty: Difficulty.Medium,
    tags: ["Greedy"],
    description: "Min intervals to finish tasks with cooling.",
    descriptionCn: "完成任务的最短时间（含冷却）。",
    solutionIdea: "Math/Greedy. (max_count - 1) * (n + 1) + num_max_tasks.",
    solutionIdeaCn: "贪心。填桶法。结果至少是 (max_freq - 1) * (n + 1) + max_freq_count。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
    exampleOutput: "8"
  },
  {
    id: 647,
    title: "Palindromic Substrings",
    titleCn: "回文子串",
    slug: "palindromic-substrings",
    difficulty: Difficulty.Medium,
    tags: ["String", "DP"],
    description: "Count palindromic substrings.",
    descriptionCn: "回文子串个数。",
    solutionIdea: "Center Expansion.",
    solutionIdeaCn: "中心扩散法。对每个点/间隙向两边扩散计数。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"abc\"",
    exampleOutput: "3"
  },
  {
    id: 739,
    title: "Daily Temperatures",
    titleCn: "每日温度",
    slug: "daily-temperatures",
    difficulty: Difficulty.Medium,
    tags: ["Stack"],
    description: "Days wait for warmer temp.",
    descriptionCn: "还要几天变暖。",
    solutionIdea: "Monotonic Stack (Decreasing).",
    solutionIdeaCn: "单调栈（递减）。当前 > 栈顶则弹出并计算距离。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "temps = [73,74,75...]",
    exampleOutput: "[1,1,4...]"
  },

  // --- HARD ---
  {
    id: 4,
    title: "Median of Two Sorted Arrays",
    titleCn: "寻找两个正序数组的中位数",
    slug: "median-of-two-sorted-arrays",
    difficulty: Difficulty.Hard,
    tags: ["Binary Search"],
    description: "Median of two sorted arrays O(log(m+n)).",
    descriptionCn: "两个有序数组的中位数。",
    solutionIdea: "Binary Search on partition of smaller array.",
    solutionIdeaCn: "对短数组分割位置进行二分。确保 maxLeft <= minRight。",
    timeComplexity: "O(log min(m,n))",
    spaceComplexity: "O(1)",
    exampleInput: "nums1 = [1,3], nums2 = [2]",
    exampleOutput: "2.0"
  },
  {
    id: 23,
    title: "Merge k Sorted Lists",
    titleCn: "合并 K 个升序链表",
    slug: "merge-k-sorted-lists",
    difficulty: Difficulty.Hard,
    tags: ["Heap"],
    description: "Merge k sorted lists.",
    descriptionCn: "合并 K 个有序链表。",
    solutionIdea: "Min-Heap.",
    solutionIdeaCn: "优先队列。将所有头节点入堆，弹出最小接在新链表后。",
    timeComplexity: "O(N log k)",
    spaceComplexity: "O(k)",
    exampleInput: "lists = [[1,4,5],[1,3,4],[2,6]]",
    exampleOutput: "[1,1,2,3,4,4,5,6]"
  },
  {
    id: 32,
    title: "Longest Valid Parentheses",
    titleCn: "最长有效括号",
    slug: "longest-valid-parentheses",
    difficulty: Difficulty.Hard,
    tags: ["Stack", "DP"],
    description: "Length of longest valid parentheses.",
    descriptionCn: "最长有效括号子串长度。",
    solutionIdea: "Stack. Store indices. Pop on ')'. Max = curr - stack_top.",
    solutionIdeaCn: "栈存索引。栈底垫底'上次断开位置'。匹配成功更新 max。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \")()())\"",
    exampleOutput: "4"
  },
  {
    id: 42,
    title: "Trapping Rain Water",
    titleCn: "接雨水",
    slug: "trapping-rain-water",
    difficulty: Difficulty.Hard,
    tags: ["Two Pointers"],
    description: "Water trapped between bars.",
    descriptionCn: "柱子能接多少水。",
    solutionIdea: "Two Pointers. min(maxL, maxR) - height.",
    solutionIdeaCn: "双指针。比较左右最高板，短板向内移动并计算水量。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "height = [0,1,0,2,1...]",
    exampleOutput: "6"
  },
  {
    id: 72,
    title: "Edit Distance",
    titleCn: "编辑距离",
    slug: "edit-distance",
    difficulty: Difficulty.Hard,
    tags: ["DP"],
    description: "Min ops to convert word1 to word2.",
    descriptionCn: "将单词 A 变 B 的最少操作数。",
    solutionIdea: "DP. min(insert, delete, replace) + 1.",
    solutionIdeaCn: "DP。dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(mn)",
    exampleInput: "word1 = \"horse\", word2 = \"ros\"",
    exampleOutput: "3"
  },
  {
    id: 76,
    title: "Minimum Window Substring",
    titleCn: "最小覆盖子串",
    slug: "minimum-window-substring",
    difficulty: Difficulty.Hard,
    tags: ["Sliding Window"],
    description: "Smallest substring covering t.",
    descriptionCn: "包含 t 所有字符的最小子串。",
    solutionIdea: "Sliding Window + Count Map.",
    solutionIdeaCn: "滑动窗口。右移扩大，满足条件后左移收缩求最小。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"ADOBECODEBANC\", t = \"ABC\"",
    exampleOutput: "\"BANC\""
  },
  {
    id: 84,
    title: "Largest Rectangle in Histogram",
    titleCn: "柱状图中最大的矩形",
    slug: "largest-rectangle-in-histogram",
    difficulty: Difficulty.Hard,
    tags: ["Stack"],
    description: "Max area rectangle in histogram.",
    descriptionCn: "柱状图中最大矩形面积。",
    solutionIdea: "Monotonic Stack (Increasing).",
    solutionIdeaCn: "单调递增栈。弹出时计算面积：height * (i - stackTop - 1)。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "heights = [2,1,5,6,2,3]",
    exampleOutput: "10"
  },
  {
    id: 85,
    title: "Maximal Rectangle",
    titleCn: "最大矩形",
    slug: "maximal-rectangle",
    difficulty: Difficulty.Hard,
    tags: ["Stack", "DP"],
    description: "Largest rectangle of 1s in binary matrix.",
    descriptionCn: "二维矩阵中全 1 的最大矩形。",
    solutionIdea: "Histogram per row. Reuse prob 84.",
    solutionIdeaCn: "每行看作柱状图底座，转化为第 84 题求解。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(n)",
    exampleInput: "matrix = [[\"1\",\"0\"...]]",
    exampleOutput: "6"
  },
  {
    id: 124,
    title: "Binary Tree Maximum Path Sum",
    titleCn: "二叉树中的最大路径和",
    slug: "binary-tree-maximum-path-sum",
    difficulty: Difficulty.Hard,
    tags: ["Tree", "DFS"],
    description: "Max path sum any node to any node.",
    descriptionCn: "任意路径最大和。",
    solutionIdea: "Recursion. Return max gain (root+max(L,R)). Update global.",
    solutionIdeaCn: "递归返回最大单边贡献。过程中计算 L+R+root 更新全局最大。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [-10,9,20,15,7]",
    exampleOutput: "42"
  },
  {
    id: 239,
    title: "Sliding Window Maximum",
    titleCn: "滑动窗口最大值",
    slug: "sliding-window-maximum",
    difficulty: Difficulty.Hard,
    tags: ["Queue"],
    description: "Max value in each sliding window.",
    descriptionCn: "滑动窗口中的最大值。",
    solutionIdea: "Monotonic Deque (Decreasing).",
    solutionIdeaCn: "单调双端队列。队头始终为当前窗口最大值索引。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(k)",
    exampleInput: "nums = [1,3,-1,-3,5,3,6,7], k = 3",
    exampleOutput: "[3,3,5,5,6,7]"
  },
  {
    id: 297,
    title: "Serialize and Deserialize Binary Tree",
    titleCn: "二叉树的序列化与反序列化",
    slug: "serialize-and-deserialize-binary-tree",
    difficulty: Difficulty.Hard,
    tags: ["Tree", "DFS", "BFS"],
    description: "Convert tree to string and back.",
    descriptionCn: "序列化和反序列化二叉树。",
    solutionIdea: "Preorder DFS or BFS Level order.",
    solutionIdeaCn: "前序遍历（带null标记）。反序列化用队列重建。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,2,3]",
    exampleOutput: "Tree object"
  },
  {
    id: 301,
    title: "Remove Invalid Parentheses",
    titleCn: "删除无效的括号",
    slug: "remove-invalid-parentheses",
    difficulty: Difficulty.Hard,
    tags: ["BFS", "Backtracking"],
    description: "Remove min parentheses to make valid.",
    descriptionCn: "删除最少括号使有效。",
    solutionIdea: "BFS for shortest path (min removals).",
    solutionIdeaCn: "BFS。第一层删1个，第二层删2个... 遇到有效即停止。",
    timeComplexity: "O(2^n)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \"()())()\"",
    exampleOutput: "[\"(())()\",\"()()()\"]"
  },
  {
    id: 312,
    title: "Burst Balloons",
    titleCn: "戳气球",
    slug: "burst-balloons",
    difficulty: Difficulty.Hard,
    tags: ["DP"],
    description: "Max coins bursting balloons.",
    descriptionCn: "戳气球获最大硬币数。",
    solutionIdea: "Interval DP. Reverse thinking: Last balloon to burst.",
    solutionIdeaCn: "区间 DP。逆向思维：枚举谁是最后一个破的。",
    timeComplexity: "O(n^3)",
    spaceComplexity: "O(n^2)",
    exampleInput: "nums = [3,1,5,8]",
    exampleOutput: "167"
  }
];

export const STORAGE_KEY = 'leetcode-flash-v6';