
import { Difficulty, Question } from './types';

export const INITIAL_QUESTIONS: Question[] = [
  // --- EASY ---
  {
    id: 1,
    title: "Two Sum",
    titleCn: "两数之和",
    slug: "two-sum",
    difficulty: Difficulty.Easy,
    tags: ["Array", "Hash Table"],
    description: "Given an array of integers `nums` and an integer `target`, return indices of the two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    descriptionCn: "给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。",
    solutionIdea: "Use a Hash Map for O(1) lookups. Iterate through the array; for each element `num`, calculate `complement = target - num`. If `complement` is in the map, return its index and the current index. Otherwise, store `num` and its index in the map.",
    solutionIdeaCn: "使用哈希表来降低时间复杂度。遍历数组，对于每个数 x，计算 target - x。检查这个差值是否已经在哈希表中：如果在，说明找到了这两个数，返回它们的索引；如果不在，将当前数 x 及其索引存入哈希表，继续遍历。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [2,7,11,15], target = 9",
    exampleOutput: "[0,1]"
  },
  {
    id: 20,
    title: "Valid Parentheses",
    titleCn: "有效的括号",
    slug: "valid-parentheses",
    difficulty: Difficulty.Easy,
    tags: ["String", "Stack"],
    description: "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. Open brackets must be closed by the same type of brackets in the correct order.",
    descriptionCn: "给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合，且闭合顺序正确。",
    solutionIdea: "Use a Stack. Iterate through the string. Push opening brackets onto the stack. When a closing bracket is encountered, check if the stack is empty (invalid) or if the top of the stack matches the closing bracket. If it matches, pop the stack. Finally, valid if stack is empty.",
    solutionIdeaCn: "利用栈的后进先出特性。遍历字符串，遇到左括号就入栈。遇到右括号时，检查栈顶元素是否是对应的左括号：若是，则弹出栈顶元素；若栈为空或不匹配，则无效。最后检查栈是否为空，空则有效。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \"()[]{}\"",
    exampleOutput: "true"
  },
  {
    id: 21,
    title: "Merge Two Sorted Lists",
    titleCn: "合并两个有序链表",
    slug: "merge-two-sorted-lists",
    difficulty: Difficulty.Easy,
    tags: ["Linked List", "Recursion"],
    description: "Merge two sorted linked lists and return it as a sorted list. The list should be made by splicing together the nodes of the first two lists.",
    descriptionCn: "将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。",
    solutionIdea: "Use a recursive approach or iterative approach with a dummy head. Compare the heads of `l1` and `l2`, attach the smaller node to the `current` pointer, and advance that list's pointer. Repeat until one list is null, then attach the remainder.",
    solutionIdeaCn: "迭代法：创建一个哨兵节点 (dummy node) 作为新链表的头。比较 l1 和 l2 当前节点的值，将较小的节点接在 dummy 后面，并移动对应的指针。循环直到其中一个链表为空，最后将非空链表的剩余部分接上。",
    timeComplexity: "O(n + m)",
    spaceComplexity: "O(1)",
    exampleInput: "l1 = [1,2,4], l2 = [1,3,4]",
    exampleOutput: "[1,1,2,3,4,4]"
  },
  {
    id: 70,
    title: "Climbing Stairs",
    titleCn: "爬楼梯",
    slug: "climbing-stairs",
    difficulty: Difficulty.Easy,
    tags: ["DP", "Math"],
    description: "You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
    descriptionCn: "假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。有多少种不同的方法可以爬到楼顶？",
    solutionIdea: "This is essentially the Fibonacci sequence. The number of ways to reach step `n` is the sum of ways to reach `n-1` (1 step jump) and `n-2` (2 step jump). Use dynamic programming or just two variables to track previous results.",
    solutionIdeaCn: "这是一个典型的斐波那契数列问题。到达第 n 阶的方法数 = 到达第 n-1 阶的方法数 + 到达第 n-2 阶的方法数。可以使用动态规划数组，或者仅用两个变量滚动更新来节省空间。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "n = 3",
    exampleOutput: "3"
  },
  {
    id: 88,
    title: "Merge Sorted Array",
    titleCn: "合并两个有序数组",
    slug: "merge-sorted-array",
    difficulty: Difficulty.Easy,
    tags: ["Array", "Two Pointers"],
    description: "Given two sorted integer arrays `nums1` and `nums2`, merge `nums2` into `nums1` as one sorted array. `nums1` has enough space (m + n) to hold additional elements.",
    descriptionCn: "给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素。",
    solutionIdea: "Use three pointers starting from the end of the arrays. Compare the last valid elements of `nums1` (index m-1) and `nums2` (index n-1), placing the larger one at the end of `nums1` (index m+n-1). This avoids overwriting elements in `nums1`.",
    solutionIdeaCn: "逆向双指针法。从 nums1 和 nums2 的末尾开始比较，将较大的数填入 nums1 的最末端（m+n-1 位置）。这样可以避免从前往后填充时覆盖 nums1 中尚未处理的元素。如果 nums2 还有剩余，直接拷贝。",
    timeComplexity: "O(m+n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums1 = [1,2,3,0,0,0], nums2 = [2,5,6]",
    exampleOutput: "[1,2,2,3,5,6]"
  },
  {
    id: 94,
    title: "Binary Tree Inorder Traversal",
    titleCn: "二叉树的中序遍历",
    slug: "binary-tree-inorder-traversal",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS", "Stack"],
    description: "Given the root of a binary tree, return the inorder traversal of its nodes' values (Left -> Root -> Right).",
    descriptionCn: "给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。（左子树 -> 根节点 -> 右子树）",
    solutionIdea: "Recursive: `inorder(node.left)`, visit `node`, `inorder(node.right)`. Iterative: Use a stack. Push all left children until null, pop and visit, then move to right child and repeat.",
    solutionIdeaCn: "递归法：先递归遍历左子树，再访问根节点，最后递归遍历右子树。迭代法：使用栈模拟递归。一直向左走将节点入栈直到为空，弹出栈顶节点并访问，然后转向其右子树重复该过程。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,null,2,3]",
    exampleOutput: "[1,3,2]"
  },
  {
    id: 101,
    title: "Symmetric Tree",
    titleCn: "对称二叉树",
    slug: "symmetric-tree",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS", "BFS"],
    description: "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).",
    descriptionCn: "给你一个二叉树的根节点 root ， 检查它是否轴对称。",
    solutionIdea: "Recursive: A tree is symmetric if the left subtree is a mirror reflection of the right subtree. `isMirror(t1, t2)` is true if `t1.val == t2.val` AND `isMirror(t1.left, t2.right)` AND `isMirror(t1.right, t2.left)`.",
    solutionIdeaCn: "递归检查：判断两棵树是否互为镜像。条件是：根节点值相等，且 树A的左子树 与 树B的右子树 镜像，树A的右子树 与 树B的左子树 镜像。初始调用 check(root.left, root.right)。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,2,2,3,4,4,3]",
    exampleOutput: "true"
  },
  {
    id: 104,
    title: "Maximum Depth of Binary Tree",
    titleCn: "二叉树的最大深度",
    slug: "maximum-depth-of-binary-tree",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS"],
    description: "Given the root of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.",
    descriptionCn: "给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。",
    solutionIdea: "DFS/Recursive: The depth of a node is `1 + max(depth(left_child), depth(right_child))`. Base case: if node is null, depth is 0.",
    solutionIdeaCn: "递归 DFS：当前树的最大深度等于 1 加上左右子树深度的较大者。即 maxDepth(root) = 1 + max(maxDepth(left), maxDepth(right))。空节点深度为 0。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [3,9,20,null,null,15,7]",
    exampleOutput: "3"
  },
  {
    id: 121,
    title: "Best Time to Buy and Sell Stock",
    titleCn: "买卖股票的最佳时机",
    slug: "best-time-to-buy-and-sell-stock",
    difficulty: Difficulty.Easy,
    tags: ["Array", "DP"],
    description: "You are given an array `prices`. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.",
    descriptionCn: "给定一个数组 prices ，其中 prices[i] 是一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出。求最大利润。",
    solutionIdea: "One Pass. Iterate through prices keeping track of the `min_price` seen so far. The potential profit at current day is `price - min_price`. Update `max_profit` if current profit is higher.",
    solutionIdeaCn: "一次遍历。维护一个 min_price 记录历史最低价。对于每天的价格，计算 (当前价格 - min_price)，这表示如果在最低点买入并在今天卖出的利润。不断更新最大利润即可。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "prices = [7,1,5,3,6,4]",
    exampleOutput: "5"
  },
  {
    id: 136,
    title: "Single Number",
    titleCn: "只出现一次的数字",
    slug: "single-number",
    difficulty: Difficulty.Easy,
    tags: ["Bit Manipulation"],
    description: "Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one. You must implement a solution with a linear runtime complexity and use only constant extra space.",
    descriptionCn: "给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。要求 O(n) 时间复杂度且不使用额外空间。",
    solutionIdea: "Bitwise XOR. XOR properties: `a ^ a = 0` and `a ^ 0 = a`. XORing all numbers together will cancel out the duplicates (they become 0), leaving only the unique number.",
    solutionIdeaCn: "位运算异或。利用异或性质：a ^ a = 0，a ^ 0 = a，且异或满足交换律。将数组所有元素进行异或，成对出现的数字会互相抵消变成 0，最终剩下的就是只出现一次的数字。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [4,1,2,1,2]",
    exampleOutput: "4"
  },
  {
    id: 141,
    title: "Linked List Cycle",
    titleCn: "环形链表",
    slug: "linked-list-cycle",
    difficulty: Difficulty.Easy,
    tags: ["Linked List", "Two Pointers"],
    description: "Given `head`, the head of a linked list, determine if the linked list has a cycle in it.",
    descriptionCn: "给定一个链表，判断链表中是否有环。如果链表中存在环，则返回 true 。否则，返回 false 。",
    solutionIdea: "Floyd's Cycle-Finding Algorithm (Tortoise and Hare). Use two pointers, `slow` moves 1 step, `fast` moves 2 steps. If there is a cycle, `fast` will eventually catch up to `slow`. If `fast` reaches null, there is no cycle.",
    solutionIdeaCn: "快慢指针法。定义两个指针，慢指针每次走一步，快指针每次走两步。如果链表有环，快指针最终会追上慢指针（相遇）；如果快指针走到链表尾部（null），则说明无环。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [3,2,0,-4], pos = 1",
    exampleOutput: "true"
  },
  {
    id: 160,
    title: "Intersection of Two Linked Lists",
    titleCn: "相交链表",
    slug: "intersection-of-two-linked-lists",
    difficulty: Difficulty.Easy,
    tags: ["Linked List", "Two Pointers"],
    description: "Given the heads of two singly linked-lists `headA` and `headB`, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.",
    descriptionCn: "给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。",
    solutionIdea: "Two Pointers approach. Initialize `pA` on headA and `pB` on headB. When `pA` reaches end, redirect to headB. When `pB` reaches end, redirect to headA. They will meet at the intersection node after (lengthA + lengthB) steps at most, effectively canceling out the length difference.",
    solutionIdeaCn: "双指针法。指针 A 遍历完链表 A 后走链表 B，指针 B 遍历完链表 B 后走链表 A。这样两个指针走的总路程相同，消除了长度差。如果相交，它们会在交点相遇；如果不相交，它们会同时指向 null。",
    timeComplexity: "O(n+m)",
    spaceComplexity: "O(1)",
    exampleInput: "listA = [4,1,8,4,5], listB = [5,6,1,8,4,5]",
    exampleOutput: "Node 8"
  },
  {
    id: 169,
    title: "Majority Element",
    titleCn: "多数元素",
    slug: "majority-element",
    difficulty: Difficulty.Easy,
    tags: ["Array", "Divide and Conquer"],
    description: "Given an array `nums` of size `n`, return the majority element. The majority element is the element that appears more than `⌊n / 2⌋` times.",
    descriptionCn: "给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。",
    solutionIdea: "Boyer-Moore Voting Algorithm. Maintain a `candidate` and a `count`. Iterate array: if `count` is 0, pick current num as candidate. If num == candidate, `count++`, else `count--`.",
    solutionIdeaCn: "摩尔投票法。维护一个候选人 candidate 和票数 count。遍历数组，如果 count 为 0，更换当前数为候选人。如果当前数等于候选人，票数+1，否则票数-1。因为众数超过一半，最后留下的肯定是众数。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,2,1,1,1,2,2]",
    exampleOutput: "2"
  },
  {
    id: 206,
    title: "Reverse Linked List",
    titleCn: "反转链表",
    slug: "reverse-linked-list",
    difficulty: Difficulty.Easy,
    tags: ["Linked List"],
    description: "Given the head of a singly linked list, reverse the list, and return the reversed list.",
    descriptionCn: "给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。",
    solutionIdea: "Iterative: Initialize `prev` to null and `curr` to head. While `curr` exists, save `next` node, set `curr.next` to `prev`, move `prev` to `curr`, and `curr` to `next`.",
    solutionIdeaCn: "迭代法：使用双指针 prev 和 curr。prev 初始为 null。遍历链表，暂存 curr 的下一个节点 next，将 curr.next 指向 prev（反转方向），然后 prev 和 curr 整体前移一步。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [1,2,3,4,5]",
    exampleOutput: "[5,4,3,2,1]"
  },
  {
    id: 226,
    title: "Invert Binary Tree",
    titleCn: "翻转二叉树",
    slug: "invert-binary-tree",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS"],
    description: "Given the root of a binary tree, invert the tree (mirror image) and return its root.",
    descriptionCn: "给你一棵二叉树的根节点 root ，翻转这棵二叉树（左右子树互换），并返回其根节点。",
    solutionIdea: "Recursive. For each node, swap its left and right children. Then recursively call invert on the left child and right child.",
    solutionIdeaCn: "递归法。对于当前节点，交换其左孩子和右孩子。然后递归地对左子树和右子树进行翻转。也可以用 BFS 层序遍历，对队列中每个节点交换左右子节点。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [4,2,7,1,3]",
    exampleOutput: "[4,7,2,3,1]"
  },
  {
    id: 234,
    title: "Palindrome Linked List",
    titleCn: "回文链表",
    slug: "palindrome-linked-list",
    difficulty: Difficulty.Easy,
    tags: ["Linked List", "Two Pointers"],
    description: "Given the head of a singly linked list, return `true` if it is a palindrome.",
    descriptionCn: "给你一个单链表的头节点 head ，请你判断该链表是否为回文链表。",
    solutionIdea: "1. Find middle using fast/slow pointers. 2. Reverse the second half of the list. 3. Compare the first half and the reversed second half node by node.",
    solutionIdeaCn: "快慢指针找中点。将链表的后半部分反转。然后双指针分别从头和中点开始向后遍历比较。如果所有值相等则为回文。最后可以再将链表复原（可选）。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [1,2,2,1]",
    exampleOutput: "true"
  },
  {
    id: 283,
    title: "Move Zeroes",
    titleCn: "移动零",
    slug: "move-zeroes",
    difficulty: Difficulty.Easy,
    tags: ["Array", "Two Pointers"],
    description: "Given an integer array `nums`, move all 0's to the end of it while maintaining the relative order of the non-zero elements. You must do this in-place.",
    descriptionCn: "给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。必须在原数组上操作。",
    solutionIdea: "Two Pointers. Use a pointer `insertPos` to track where the next non-zero element should go. Iterate through array; if current element is not 0, swap it with element at `insertPos` and increment `insertPos`.",
    solutionIdeaCn: "双指针法。指针 j 指向当前需要放置非零数的位置。遍历数组，遇到非零数 nums[i]，就将其交换到 nums[j]，同时 j++。这样所有的非零数都移到了前面，0 自然就被交换到了后面。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [0,1,0,3,12]",
    exampleOutput: "[1,3,12,0,0]"
  },
  {
    id: 338,
    title: "Counting Bits",
    titleCn: "比特位计数",
    slug: "counting-bits",
    difficulty: Difficulty.Easy,
    tags: ["DP", "Bit Manipulation"],
    description: "Given an integer `n`, return an array `ans` of length `n + 1` such that for each `i` (0 <= i <= n), `ans[i]` is the number of 1's in the binary representation of `i`.",
    descriptionCn: "给你一个整数 n ，对于 0 <= i <= n 中的每个 i ，计算其二进制表示中 1 的个数 ，返回一个长度为 n + 1 的数组 ans 作为答案。",
    solutionIdea: "Dynamic Programming. Relationships: `bits[i] = bits[i >> 1] + (i & 1)`. The number of set bits in `i` is the same as `i/2`, plus 1 if `i` is odd.",
    solutionIdeaCn: "动态规划 + 位运算。状态转移方程：dp[i] = dp[i >> 1] + (i & 1)。解释：i 的二进制 1 的个数等于 i/2 (右移一位) 的 1 的个数，加上 i 的最后一位是否为 1 (奇偶性)。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "n = 2",
    exampleOutput: "[0,1,1]"
  },
  {
    id: 448,
    title: "Find All Numbers Disappeared",
    titleCn: "找到所有数组中消失的数字",
    slug: "find-all-numbers-disappeared-in-an-array",
    difficulty: Difficulty.Easy,
    tags: ["Array"],
    description: "Given an array `nums` of `n` integers where `nums[i]` is in the range `[1, n]`, return an array of all the integers in the range `[1, n]` that do not appear in `nums`.",
    descriptionCn: "给你一个含 n 个整数的数组 nums ，其中 nums[i] 在区间 [1, n] 内。请你找出所有在 [1, n] 范围内但没有出现在 nums 中的数字。",
    solutionIdea: "Index Marking. Iterate through the array. For each number `x`, treat `abs(x) - 1` as an index and mark the value at that index as negative. Finally, indices containing positive numbers correspond to missing values.",
    solutionIdeaCn: "原地哈希/索引标记。利用数组元素值对应下标。遍历数组，将元素 |x| 对应的下标 |x|-1 处的数字变成负数。再次遍历，如果下标 i 处的数字仍为正数，说明 i+1 这个数字从未出现过。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [4,3,2,7,8,2,3,1]",
    exampleOutput: "[5,6]"
  },
  {
    id: 461,
    title: "Hamming Distance",
    titleCn: "汉明距离",
    slug: "hamming-distance",
    difficulty: Difficulty.Easy,
    tags: ["Bit Manipulation"],
    description: "The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers `x` and `y`, return the Hamming distance.",
    descriptionCn: "两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 x 和 y，计算并返回它们之间的汉明距离。",
    solutionIdea: "XOR `x` and `y`. The result will have 1s bits only where bits differed. Then count the number of 1s (set bits) in the result (Brian Kernighan's algorithm or built-in function).",
    solutionIdeaCn: "异或运算。对 x 和 y 进行异或操作，相同位为 0，不同位为 1。结果中 1 的个数即为汉明距离。可以使用 `n & (n-1)` 循环消除最低位 1 来统计个数。",
    timeComplexity: "O(1)",
    spaceComplexity: "O(1)",
    exampleInput: "x = 1, y = 4",
    exampleOutput: "2"
  },
  {
    id: 543,
    title: "Diameter of Binary Tree",
    titleCn: "二叉树的直径",
    slug: "diameter-of-binary-tree",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS"],
    description: "Given the root of a binary tree, return the length of the diameter of the tree. The diameter is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.",
    descriptionCn: "给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个节点路径长度中的最大值。这条路径可能穿过也可能不穿过根节点。",
    solutionIdea: "DFS. The longest path through a specific node is `depth(left) + depth(right)`. Iterate through all nodes (via recursion), calculating this sum, and update a global `maxDiameter`. The function returns `max(depth(left), depth(right)) + 1`.",
    solutionIdeaCn: "深度优先搜索。对于每个节点，经过该节点的最长路径 = 左子树深度 + 右子树深度。我们需要维护一个全局变量 max_d，在递归计算每个节点的深度时，顺便更新 max_d。函数返回值为该节点的最大深度。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,2,3,4,5]",
    exampleOutput: "3"
  },
  {
    id: 617,
    title: "Merge Two Binary Trees",
    titleCn: "合并二叉树",
    slug: "merge-two-binary-trees",
    difficulty: Difficulty.Easy,
    tags: ["Tree", "DFS"],
    description: "You are given two binary trees `root1` and `root2`. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. Merge them so that overlapped nodes sum up.",
    descriptionCn: "给定两个二叉树，想象当你将它们覆盖在一起时，有些节点重叠。你需要合并它们：如果两个节点重叠，将它们的值相加作为新节点的值；否则不为 NULL 的节点将直接作为新节点。",
    solutionIdea: "Recursive. If both nodes are null, return null. If one is null, return the other. If both exist, create a new node with sum of values, and recursively merge left and right children.",
    solutionIdeaCn: "递归法。如果两个节点都为空，返回空。如果其中一个为空，返回另一个。如果都不为空，将值相加修改当前节点（或新建节点），然后递归合并左子树和右子树。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]",
    exampleOutput: "[3,4,5,5,4,null,7]"
  },

  // --- MEDIUM ---
  {
    id: 2,
    title: "Add Two Numbers",
    titleCn: "两数相加",
    slug: "add-two-numbers",
    difficulty: Difficulty.Medium,
    tags: ["Linked List", "Math"],
    description: "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.",
    descriptionCn: "给你两个非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。",
    solutionIdea: "Simulate addition digit by digit. Iterate through both lists, tracking a `carry`. `sum = val1 + val2 + carry`. New node value is `sum % 10`, new carry is `sum / 10`.",
    solutionIdeaCn: "模拟加法运算。遍历两个链表，维护一个进位 carry。每一位的值 = (l1.val + l2.val + carry) % 10，新进位 = sum / 10。注意最后如果 carry > 0 还需要新建一个节点。",
    timeComplexity: "O(max(m,n))",
    spaceComplexity: "O(max(m,n))",
    exampleInput: "l1 = [2,4,3], l2 = [5,6,4]",
    exampleOutput: "[7,0,8]"
  },
  {
    id: 3,
    title: "Longest Substring Without Repeating Characters",
    titleCn: "无重复字符的最长子串",
    slug: "longest-substring-without-repeating-characters",
    difficulty: Difficulty.Medium,
    tags: ["Sliding Window", "Hash Table"],
    description: "Given a string `s`, find the length of the longest substring without repeating characters.",
    descriptionCn: "给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。",
    solutionIdea: "Sliding Window with Hash Map. Keep a window `[left, right]`. Map stores the last seen index of each char. If `s[right]` is in map, update `left` to `max(left, map[s[right]] + 1)`.",
    solutionIdeaCn: "滑动窗口 + 哈希表。使用双指针维护一个无重复字符窗口。哈希表记录字符上一次出现的位置。遍历时，若字符已存在且在窗口内，移动左边界到该字符上一次出现位置的右边。始终维护最大窗口长度。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"abcabcbb\"",
    exampleOutput: "3"
  },
  {
    id: 5,
    title: "Longest Palindromic Substring",
    titleCn: "最长回文子串",
    slug: "longest-palindromic-substring",
    difficulty: Difficulty.Medium,
    tags: ["DP", "String"],
    description: "Given a string `s`, return the longest palindromic substring in `s`.",
    descriptionCn: "给你一个字符串 s，找到 s 中最长的回文子串。",
    solutionIdea: "Expand Around Center. A palindrome mirrors around its center. Iterate through each character (and gap) as a center, expanding `left` and `right` while `s[left] == s[right]`.",
    solutionIdeaCn: "中心扩散法。回文串中心可能是一个字符（奇数长度）或两个字符（偶数长度）。遍历字符串，以每个位置为中心向两边扩散，直到两端字符不相等。记录最长的回文子串。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"babad\"",
    exampleOutput: "\"bab\""
  },
  {
    id: 11,
    title: "Container With Most Water",
    titleCn: "盛最多水的容器",
    slug: "container-with-most-water",
    difficulty: Difficulty.Medium,
    tags: ["Two Pointers"],
    description: "Given `n` non-negative integers representing vertical lines, find two lines that together with the x-axis form a container, such that the container contains the most water.",
    descriptionCn: "给定一个长度为 n 的整数数组 height。找出两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。",
    solutionIdea: "Two Pointers. Start with max width (first and last lines). `Area = min(height[left], height[right]) * width`. Always move the pointer of the shorter line inward to try and find a taller line.",
    solutionIdeaCn: "双指针贪心。左右指针分别指向数组两端。面积由短板决定。计算当前面积后，将高度较小的那个指针向内移动（因为如果不移动短板，面积受限于短板不可能变大）。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "height = [1,8,6,2,5,4,8,3,7]",
    exampleOutput: "49"
  },
  {
    id: 15,
    title: "3Sum",
    titleCn: "三数之和",
    slug: "3sum",
    difficulty: Difficulty.Medium,
    tags: ["Two Pointers", "Sorting"],
    description: "Given an integer array nums, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, `j != k`, and `nums[i] + nums[j] + nums[k] == 0`. Notice that the solution set must not contain duplicate triplets.",
    descriptionCn: "给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。",
    solutionIdea: "Sort the array. Iterate `i` from 0 to n-2. For each `i`, use Two Pointers `left` and `right` to find pairs summing to `-nums[i]`. Skip duplicates to ensure unique triplets.",
    solutionIdeaCn: "排序 + 双指针。先对数组排序。遍历固定第一个数 nums[i]，然后用双指针 L, R 在 i 后面寻找和为 -nums[i] 的两个数。注意在遍历和移动指针时跳过重复的数值以避免重复解。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [-1,0,1,2,-1,-4]",
    exampleOutput: "[[-1,-1,2],[-1,0,1]]"
  },
  {
    id: 17,
    title: "Letter Combinations of a Phone Number",
    titleCn: "电话号码的字母组合",
    slug: "letter-combinations-of-a-phone-number",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. (Like old T9 texting).",
    descriptionCn: "给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。（对应九宫格输入法）",
    solutionIdea: "Backtracking. Maintain a mapping of digit to letters. Recursively build strings: for current digit, iterate through its possible letters, append to current path, and recurse for next digit.",
    solutionIdeaCn: "回溯法。建立数字到字母的映射表。递归函数维护当前组合的字符串和当前处理的数字索引。遍历当前数字对应的所有字母，拼接到组合后，递归处理下一个数字。",
    timeComplexity: "O(4^n)",
    spaceComplexity: "O(n)",
    exampleInput: "digits = \"23\"",
    exampleOutput: "[\"ad\",\"ae\",\"af\",...]"
  },
  {
    id: 19,
    title: "Remove Nth Node From End of List",
    titleCn: "删除链表的倒数第 N 个结点",
    slug: "remove-nth-node-from-end-of-list",
    difficulty: Difficulty.Medium,
    tags: ["Linked List", "Two Pointers"],
    description: "Given the head of a linked list, remove the `nth` node from the end of the list and return its head.",
    descriptionCn: "给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。",
    solutionIdea: "Two Pointers. Move `fast` pointer `n` steps ahead. Then move both `fast` and `slow` until `fast` reaches the end. `slow` will be at the node before the target. Update `slow.next`.",
    solutionIdeaCn: "双指针。让快指针 fast 先走 n 步。然后快慢指针 fast 和 slow 同时移动，直到 fast 到达链表末尾。此时 slow 指向倒数第 n+1 个节点。修改 slow.next 即可删除倒数第 n 个节点。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [1,2,3,4,5], n = 2",
    exampleOutput: "[1,2,3,5]"
  },
  {
    id: 22,
    title: "Generate Parentheses",
    titleCn: "括号生成",
    slug: "generate-parentheses",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.",
    descriptionCn: "数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。",
    solutionIdea: "Backtracking. Keep track of `open` and `close` counts. If `open < n`, add '('. If `close < open`, add ')'. Base case: string length == 2*n.",
    solutionIdeaCn: "回溯法（剪枝）。记录左括号数量 open 和右括号数量 close。如果 open < n，可以添加 '('；如果 close < open，可以添加 ')'。当字符串长度达到 2n 时加入结果集。",
    timeComplexity: "O(4^n/sqrt(n))",
    spaceComplexity: "O(n)",
    exampleInput: "n = 3",
    exampleOutput: "[\"((()))\",...]"
  },
  {
    id: 31,
    title: "Next Permutation",
    titleCn: "下一个排列",
    slug: "next-permutation",
    difficulty: Difficulty.Medium,
    tags: ["Array"],
    description: "Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If no such arrangement is possible, rearrange as the lowest possible order (sorted ascending).",
    descriptionCn: "实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（升序）。",
    solutionIdea: "1. Find first decreasing element from right (`i`). 2. Find element larger than `nums[i]` from right (`j`). 3. Swap `nums[i]` and `nums[j]`. 4. Reverse subarray after `i`.",
    solutionIdeaCn: "1. 从后往前找第一个相邻升序对 (i, i+1)，nums[i] < nums[i+1]。2. 在 i 后面找比 nums[i] 大的最小数 nums[j]。3. 交换 nums[i] 和 nums[j]。4. 反转 i 之后的所有元素使其变为升序。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [1,2,3]",
    exampleOutput: "[1,3,2]"
  },
  {
    id: 33,
    title: "Search in Rotated Sorted Array",
    titleCn: "搜索旋转排序数组",
    slug: "search-in-rotated-sorted-array",
    difficulty: Difficulty.Medium,
    tags: ["Binary Search"],
    description: "There is an integer array `nums` sorted in ascending order (with distinct values) that is rotated at an unknown pivot index. Given `target`, return the index of `target` or -1.",
    descriptionCn: "整数数组 nums 按升序排列，但在未知枢纽处进行了旋转。给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值，则返回它的下标，否则返回 -1 。",
    solutionIdea: "Binary Search. One half of the array is always sorted. Check if `mid` element splits sorted left or sorted right. Then check if `target` lies within the sorted half to decide which way to move.",
    solutionIdeaCn: "二分查找。旋转数组的一分为二后，总有一半是有序的。判断 nums[low] <= nums[mid] 可知左半边是否有序。若左半有序且 target 在范围内，搜左边；否则搜右边。反之亦然。",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [4,5,6,7,0,1,2], target = 0",
    exampleOutput: "4"
  },
  {
    id: 34,
    title: "Find First and Last Position",
    titleCn: "在排序数组中查找元素的第一个和最后一个位置",
    slug: "find-first-and-last-position-of-element-in-sorted-array",
    difficulty: Difficulty.Medium,
    tags: ["Binary Search"],
    description: "Given an array of integers `nums` sorted in non-decreasing order, find the starting and ending position of a given `target` value. O(log n) required.",
    descriptionCn: "给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。必须 O(log n)。",
    solutionIdea: "Run Binary Search twice. First, find the leftmost index where `nums[mid] == target` (lower bound). Second, find the rightmost index (upper bound).",
    solutionIdeaCn: "两次二分查找。第一次找 >= target 的第一个位置（左边界）。第二次找 > target 的第一个位置再减一（或者找 <= target 的最后一个位置，即右边界）。",
    timeComplexity: "O(log n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [5,7,7,8,8,10], target = 8",
    exampleOutput: "[3,4]"
  },
  {
    id: 39,
    title: "Combination Sum",
    titleCn: "组合总和",
    slug: "combination-sum",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "Given distinct integers `candidates` and a `target`, return a list of all unique combinations where the chosen numbers sum to `target`. You may choose the same number unlimited times.",
    descriptionCn: "给你一个无重复元素的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。数字可以被无限制重复被选取。",
    solutionIdea: "Backtracking. Sort candidates (optional optimization). Function `dfs(index, remain)`. Iterate `i` from `index` to end. If `candidates[i] <= remain`, include it and recurse `dfs(i, remain - val)`. Note we pass `i` not `i+1` to allow reuse.",
    solutionIdeaCn: "回溯法。定义 dfs(index, target)。从 index 开始遍历数组，如果当前数 <= target，将其加入路径，并递归调用 dfs(i, target - nums[i])（注意这里传入 i 表示可以重复选当前数）。回溯时移除当前数。",
    timeComplexity: "O(S)",
    spaceComplexity: "O(target)",
    exampleInput: "candidates = [2,3,6,7], target = 7",
    exampleOutput: "[[2,2,3],[7]]"
  },
  {
    id: 46,
    title: "Permutations",
    titleCn: "全排列",
    slug: "permutations",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.",
    descriptionCn: "给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。",
    solutionIdea: "Backtracking. Use a `used` boolean array or swap elements. For each position, try every unused number. Swap current index with iteration index, recurse, then swap back (backtrack).",
    solutionIdeaCn: "回溯法。可以维护一个 visited 数组，或者通过交换元素来实现。枚举当前位置 i 可以填入的数字（从 i 到 n），交换 nums[i] 和 nums[j]，递归填下一个位置，回溯时再交换回来。",
    timeComplexity: "O(n*n!)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [1,2,3]",
    exampleOutput: "[[1,2,3],...]"
  },
  {
    id: 48,
    title: "Rotate Image",
    titleCn: "旋转图像",
    slug: "rotate-image",
    difficulty: Difficulty.Medium,
    tags: ["Matrix"],
    description: "You are given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place.",
    descriptionCn: "给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 原地 旋转图像。",
    solutionIdea: "Transpose then Reverse. 1. Transpose the matrix (swap `matrix[i][j]` with `matrix[j][i]`). 2. Reverse each row.",
    solutionIdeaCn: "先转置，再翻转。1. 沿主对角线交换元素 matrix[i][j] 和 matrix[j][i]。2. 每一行左右翻转（reverse）。这样就实现了顺时针旋转 90 度。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(1)",
    exampleInput: "matrix = [[1,2,3],[4,5,6],[7,8,9]]",
    exampleOutput: "[[7,4,1],[8,5,2],[9,6,3]]"
  },
  {
    id: 49,
    title: "Group Anagrams",
    titleCn: "字母异位词分组",
    slug: "group-anagrams",
    difficulty: Difficulty.Medium,
    tags: ["Hash Table"],
    description: "Given an array of strings `strs`, group the anagrams together. An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase.",
    descriptionCn: "给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。字母异位词是由重新排列源单词的字母得到的一个新单词。",
    solutionIdea: "Hash Map. Key: Sorted string (e.g., 'ate', 'eat' -> 'aet') OR Character Count string (e.g., '1a1e1t'). Value: List of strings. Iterate words, compute key, append to map.",
    solutionIdeaCn: "哈希表分类。遍历字符串数组。对每个字符串，将其字符排序作为 Key（或者用 26 个字母的计数作为 Key）。将原始字符串加入该 Key 对应的列表中。",
    timeComplexity: "O(nk log k)",
    spaceComplexity: "O(nk)",
    exampleInput: "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
    exampleOutput: "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]"
  },
  {
    id: 53,
    title: "Maximum Subarray",
    titleCn: "最大子数组和",
    slug: "maximum-subarray",
    difficulty: Difficulty.Medium,
    tags: ["DP", "Array"],
    description: "Given an integer array `nums`, find the subarray with the largest sum, and return its sum.",
    descriptionCn: "给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。",
    solutionIdea: "Kadane's Algorithm. Iterate array. `current_sum = max(num, current_sum + num)`. `max_sum = max(max_sum, current_sum)`. Basically, if prefix sum becomes negative, discard it and start fresh.",
    solutionIdeaCn: "贪心/动态规划 (Kadane算法)。遍历数组，维护当前累加和 currentSum。如果 currentSum < 0，说明对后面没有贡献，重置为当前数字。每次迭代更新全局最大值 maxSum。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [-2,1,-3,4,-1,2,1,-5,4]",
    exampleOutput: "6"
  },
  {
    id: 55,
    title: "Jump Game",
    titleCn: "跳跃游戏",
    slug: "jump-game",
    difficulty: Difficulty.Medium,
    tags: ["Greedy"],
    description: "You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position. Return `true` if you can reach the last index.",
    descriptionCn: "给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个下标。",
    solutionIdea: "Greedy. Maintain `maxReach` (furthest index reachable). Iterate `i`. If `i > maxReach`, fail. Else update `maxReach = max(maxReach, i + nums[i])`. If `maxReach >= lastIndex`, return true.",
    solutionIdeaCn: "贪心算法。维护一个变量 maxReach，表示目前能到达的最远位置。遍历数组，如果当前位置 i 在 maxReach 范围内，则更新 maxReach = max(maxReach, i + nums[i])。如果 maxReach 超过了终点，返回 true。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,3,1,1,4]",
    exampleOutput: "true"
  },
  {
    id: 56,
    title: "Merge Intervals",
    titleCn: "合并区间",
    slug: "merge-intervals",
    difficulty: Difficulty.Medium,
    tags: ["Sorting", "Array"],
    description: "Given an array of `intervals` where `intervals[i] = [start, end]`, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.",
    descriptionCn: "以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [start, end] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组。",
    solutionIdea: "Sort by start time. Iterate intervals. If `current.start <= previous.end`, merge them by updating `previous.end = max(previous.end, current.end)`. Else, push current to result.",
    solutionIdeaCn: "先按区间左端点排序。然后遍历区间：如果当前区间的左端点 <= 结果集中最后一个区间的右端点，说明重叠，更新结果集最后一个区间的右端点（取较大值）；否则，将当前区间直接加入结果集。",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(n)",
    exampleInput: "intervals = [[1,3],[2,6],[8,10]]",
    exampleOutput: "[[1,6],[8,10]]"
  },
  {
    id: 62,
    title: "Unique Paths",
    titleCn: "不同路径",
    slug: "unique-paths",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "A robot on an `m x n` grid wants to move from top-left to bottom-right. It can only move down or right. How many unique paths are there?",
    descriptionCn: "一个机器人位于一个 m x n 网格的左上角 。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。问总共有多少条不同的路径？",
    solutionIdea: "DP. `dp[i][j]` = paths to reach (i, j). `dp[i][j] = dp[i-1][j] + dp[i][j-1]`. First row and col are all 1. Optimization: Use 1D array.",
    solutionIdeaCn: "动态规划。dp[i][j] 代表到达位置 (i, j) 的路径数。由于只能从上或左来，dp[i][j] = dp[i-1][j] + dp[i][j-1]。第一行和第一列初始化为 1。空间可优化为一维数组。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(n)",
    exampleInput: "m = 3, n = 7",
    exampleOutput: "28"
  },
  {
    id: 64,
    title: "Minimum Path Sum",
    titleCn: "最小路径和",
    slug: "minimum-path-sum",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Given a `m x n` grid filled with non-negative numbers, find a path from top-left to bottom-right which minimizes the sum of all numbers along its path.",
    descriptionCn: "给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。",
    solutionIdea: "DP. `grid[i][j] += min(grid[i-1][j], grid[i][j-1])`. Calculate min sum to reach each cell in-place.",
    solutionIdeaCn: "动态规划。原地修改 grid 或使用 dp 数组。当前格子的最小路径和 = 当前值 + min(上方格子的路径和, 左方格子的路径和)。边界情况（第一行第一列）单独处理。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(1)",
    exampleInput: "grid = [[1,3,1],[1,5,1],[4,2,1]]",
    exampleOutput: "7"
  },
  {
    id: 75,
    title: "Sort Colors",
    titleCn: "颜色分类",
    slug: "sort-colors",
    difficulty: Difficulty.Medium,
    tags: ["Two Pointers", "Sorting"],
    description: "Given `nums` with 0s (red), 1s (white), and 2s (blue), sort them in-place so identical colors are adjacent in order 0, 1, 2.",
    descriptionCn: "给定一个包含红色、白色和蓝色，共 n 个元素的数组 nums ，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。(0, 1, 2)",
    solutionIdea: "Dutch National Flag Algorithm (3 Pointers). `p0` for 0s boundary, `p2` for 2s boundary, `curr` iterates. If 0, swap with `p0`, `p0++`, `curr++`. If 2, swap with `p2`, `p2--`. If 1, `curr++`.",
    solutionIdeaCn: "荷兰国旗问题（三指针）。p0 指向 0 的右边界，p2 指向 2 的左边界，curr 遍历。若 nums[curr] == 0，与 p0 交换，p0++, curr++；若 == 2，与 p2 交换，p2--（curr 不动，需再次检查）；若 == 1，curr++。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,0,2,1,1,0]",
    exampleOutput: "[0,0,1,1,2,2]"
  },
  {
    id: 78,
    title: "Subsets",
    titleCn: "子集",
    slug: "subsets",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking"],
    description: "Given an integer array `nums` of unique elements, return all possible subsets (the power set).",
    descriptionCn: "给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。解集 不能 包含重复的子集。",
    solutionIdea: "Backtracking. For each element, we have 2 choices: include it or exclude it. `dfs(index, currentPath)`. Recurse with `index+1`.",
    solutionIdeaCn: "回溯法。对于数组中每个数字，都有“选”或“不选”两种选择。dfs(i, path) 表示考虑第 i 个数。一种情况是把 nums[i] 加入 path 后递归下一层，另一种是不加入直接递归下一层。",
    timeComplexity: "O(n*2^n)",
    spaceComplexity: "O(n*2^n)",
    exampleInput: "nums = [1,2,3]",
    exampleOutput: "[[],[1],[2],[1,2]...]"
  },
  {
    id: 79,
    title: "Word Search",
    titleCn: "单词搜索",
    slug: "word-search",
    difficulty: Difficulty.Medium,
    tags: ["Backtracking", "Matrix"],
    description: "Given an `m x n` grid of characters and a string `word`, return `true` if `word` exists in the grid. The word can be constructed from letters of sequentially adjacent cells.",
    descriptionCn: "给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。单词必须按照字母顺序，通过相邻的单元格内的字母构成。",
    solutionIdea: "DFS/Backtracking. Iterate every cell. If cell matches first char, start DFS. In DFS, mark cell visited (e.g., replace char), check 4 directions for next char, then backtrack (restore char).",
    solutionIdeaCn: "DFS 回溯。遍历网格每个点作为起点。如果字符匹配，向四个方向递归搜索下一个字符。搜索前将当前格标记为已访问（如改为 '#'），搜索结束后还原（回溯）。",
    timeComplexity: "O(mn*3^L)",
    spaceComplexity: "O(L)",
    exampleInput: "board = ... word = \"ABCCED\"",
    exampleOutput: "true"
  },
  {
    id: 96,
    title: "Unique BSTs",
    titleCn: "不同的二叉搜索树",
    slug: "unique-binary-search-trees",
    difficulty: Difficulty.Medium,
    tags: ["DP", "Tree"],
    description: "Given an integer `n`, return the number of structurally unique BST's (binary search trees) which has exactly `n` nodes of unique values from `1` to `n`.",
    descriptionCn: "给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？",
    solutionIdea: "DP (Catalan Numbers). Pick `i` as root (1 to n). Left subtree has `i-1` nodes, right has `n-i`. `dp[n] = sum(dp[i-1] * dp[n-i])` for all `i`.",
    solutionIdeaCn: "动态规划（卡特兰数）。遍历 1 到 n 每个数字作为根节点 i。左子树节点数为 i-1，右子树节点数为 n-i。种数 = 左子树种数 * 右子树种数。dp[n] = Σ(dp[k] * dp[n-1-k])。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(n)",
    exampleInput: "n = 3",
    exampleOutput: "5"
  },
  {
    id: 98,
    title: "Validate Binary Search Tree",
    titleCn: "验证二叉搜索树",
    slug: "validate-binary-search-tree",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Given the root of a binary tree, determine if it is a valid binary search tree (BST).",
    descriptionCn: "给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。",
    solutionIdea: "Recursion with range. `isValid(node, min, max)`. Left child must be in `(min, node.val)`, right child in `(node.val, max)`. Or Inorder Traversal check sorted.",
    solutionIdeaCn: "递归带范围。辅助函数 check(root, lower, upper)。递归时，左子树的上限更新为 root.val，右子树的下限更新为 root.val。或者：中序遍历，检查结果是否严格单调递增。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [2,1,3]",
    exampleOutput: "true"
  },
  {
    id: 102,
    title: "Binary Tree Level Order Traversal",
    titleCn: "二叉树的层序遍历",
    slug: "binary-tree-level-order-traversal",
    difficulty: Difficulty.Medium,
    tags: ["BFS", "Tree"],
    description: "Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).",
    descriptionCn: "给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。",
    solutionIdea: "BFS with Queue. Keep track of level size. Loop `size` times to pop current level nodes and push their children for next level.",
    solutionIdeaCn: "BFS 队列。在 while 循环内部再加一个 for 循环，次数为当前队列长度（即当前层节点数）。将当前层所有节点出队并加入结果列表，同时将其左右子节点入队。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [3,9,20...]",
    exampleOutput: "[[3],[9,20]...]"
  },
  {
    id: 105,
    title: "Construct Tree from Pre/Inorder",
    titleCn: "从前序与中序遍历构造二叉树",
    slug: "construct-binary-tree-from-preorder-and-inorder-traversal",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "Recursion"],
    description: "Given preorder and inorder traversal arrays, construct and return the binary tree.",
    descriptionCn: "给定一棵树的前序遍历 preorder 和中序遍历 inorder ，请构造二叉树并返回其根节点。",
    solutionIdea: "Recursion. First element of preorder is Root. Find Root in inorder to split Left/Right subtrees. Calculate size of left subtree to split preorder array.",
    solutionIdeaCn: "递归。前序遍历的第一个是根节点。在中序遍历中找到根节点的位置，从而划分出左子树和右子树的范围。根据左子树的长度，在前序遍历中也能划分出左右子树范围。递归构建。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "pre = [3,9,20,15,7], in = [9,3,15,20,7]",
    exampleOutput: "[3,9,20...]"
  },
  {
    id: 114,
    title: "Flatten Binary Tree to Linked List",
    titleCn: "二叉树展开为链表",
    slug: "flatten-binary-tree-to-linked-list",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Flatten the tree into a \"linked list\": use the right child pointer for the next node, left child always null, preorder traversal order.",
    descriptionCn: "给你二叉树的根结点 root ，请你将它展开为一个单链表：展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而 left 子指针始终为 null 。展开后的单链表应该与二叉树 先序遍历 顺序相同。",
    solutionIdea: "Post-order like recursion (Right-Left-Root) maintaining `prev` node. Or Morris Traversal: for each node, find rightmost of left subtree, attach right child there, move left to right.",
    solutionIdeaCn: "方法一：变形后序遍历（右->左->根），用 prev 指针记录上一个访问的节点，当前节点 right 指向 prev，left 置空。方法二：寻找前驱节点。将当前节点的右子树接到左子树的最右节点上，然后将左子树移到右边。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,2,5...]",
    exampleOutput: "[1,null,2...]"
  },
  {
    id: 128,
    title: "Longest Consecutive Sequence",
    titleCn: "最长连续序列",
    slug: "longest-consecutive-sequence",
    difficulty: Difficulty.Medium,
    tags: ["Hash Table"],
    description: "Given an unsorted array of integers, find the length of the longest consecutive elements sequence. Must be O(n).",
    descriptionCn: "给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 O(n) 的算法。",
    solutionIdea: "Hash Set. Insert all nums into Set. Iterate nums. If `num-1` is NOT in set, `num` is start of sequence. Loop `num+1` checking set to count length.",
    solutionIdeaCn: "哈希集合。将所有数存入 Set 去重。遍历 Set 中的数 x，如果 x-1 不在 Set 中，说明 x 是序列起点。然后不断查询 x+1, x+2... 是否存在，计算长度。这样每个数最多被访问两次。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [100,4,200,1,3,2]",
    exampleOutput: "4"
  },
  {
    id: 139,
    title: "Word Break",
    titleCn: "单词拆分",
    slug: "word-break",
    difficulty: Difficulty.Medium,
    tags: ["DP", "String"],
    description: "Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of one or more dictionary words.",
    descriptionCn: "给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断 s 是否可以被空格拆分为一个或多个在字典中出现的单词。",
    solutionIdea: "DP. `dp[i]` is true if `s[0...i]` can be broken. `dp[i] = dp[j] && s[j...i] in dict` for some `0 <= j < i`.",
    solutionIdeaCn: "动态规划。dp[i] 表示字符串前 i 个字符能否被拆分。遍历 j < i，如果 dp[j] 为真且 s[j:i] 在字典中，则 dp[i] 为真。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \"leetcode\", dict = [\"leet\",\"code\"]",
    exampleOutput: "true"
  },
  {
    id: 142,
    title: "Linked List Cycle II",
    titleCn: "环形链表 II",
    slug: "linked-list-cycle-ii",
    difficulty: Difficulty.Medium,
    tags: ["Linked List"],
    description: "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return `null`.",
    descriptionCn: "给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。",
    solutionIdea: "Fast/Slow Pointers. 1. Detect cycle (meet point). 2. Reset one pointer to head. 3. Move both 1 step at a time. They meet at entrance.",
    solutionIdeaCn: "快慢指针。第一步先判断是否有环（相遇）。第二步将其中一个指针指回 head，另一个在相遇点。第三步两个指针每次各走一步，再次相遇的点就是入环点。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "head = [3,2,0,-4]",
    exampleOutput: "node index 1"
  },
  {
    id: 146,
    title: "LRU Cache",
    titleCn: "LRU 缓存",
    slug: "lru-cache",
    difficulty: Difficulty.Medium,
    tags: ["Design"],
    description: "Design a data structure that follows the constraints of a Least Recently Used (LRU) cache. Implement `get` and `put` in O(1).",
    descriptionCn: "请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。实现 get 和 put 操作，且时间复杂度为 O(1)。",
    solutionIdea: "Hash Map + Doubly Linked List. Map stores key -> node. List maintains order (head=recent, tail=old). `get`: move node to head. `put`: add/update node to head, remove tail if full.",
    solutionIdeaCn: "哈希表 + 双向链表。哈希表映射 key 到链表节点，实现 O(1) 查找。双向链表维护访问顺序，头部为最新，尾部为最久。访问节点时将其移到表头；容量满时删除表尾节点。",
    timeComplexity: "O(1)",
    spaceComplexity: "O(capacity)",
    exampleInput: "put(1,1), put(2,2), get(1)...",
    exampleOutput: "..."
  },
  {
    id: 148,
    title: "Sort List",
    titleCn: "排序链表",
    slug: "sort-list",
    difficulty: Difficulty.Medium,
    tags: ["Linked List", "Sorting"],
    description: "Given the head of a linked list, return the list after sorting it in ascending order. Time: O(n log n), Space: O(1) or O(log n).",
    descriptionCn: "给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。要求时间复杂度 O(n log n)。",
    solutionIdea: "Merge Sort. 1. Find middle (fast/slow). 2. Cut list. 3. Recursively sort both halves. 4. Merge sorted lists.",
    solutionIdeaCn: "归并排序。使用快慢指针找到链表中点并断开。递归地对左右两部分进行排序。最后合并两个有序链表 (Merge Two Sorted Lists)。",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(log n)",
    exampleInput: "head = [4,2,1,3]",
    exampleOutput: "[1,2,3,4]"
  },
  {
    id: 152,
    title: "Maximum Product Subarray",
    titleCn: "乘积最大子数组",
    slug: "maximum-product-subarray",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Given an integer array `nums`, find a subarray that has the largest product, and return the product.",
    descriptionCn: "给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组，并返回该子数组所对应的乘积。",
    solutionIdea: "DP. Keep track of both `max_prod` and `min_prod` because multiplying by a negative reverses logic. `curMax = max(n, n*prevMax, n*prevMin)`.",
    solutionIdeaCn: "动态规划。由于负负得正，需要同时维护当前最大乘积 maxDP 和最小乘积 minDP。遍历数组，更新 maxDP = max(num, num*preMax, num*preMin)。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,3,-2,4]",
    exampleOutput: "6"
  },
  {
    id: 155,
    title: "Min Stack",
    titleCn: "最小栈",
    slug: "min-stack",
    difficulty: Difficulty.Easy,
    tags: ["Stack"],
    description: "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.",
    descriptionCn: "设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。",
    solutionIdea: "Two Stacks. One main stack for data, one `minStack` to store the minimum value at each level. Push: if val <= minStack.top, push to minStack. Pop: if val == minStack.top, pop minStack.",
    solutionIdeaCn: "辅助栈。主栈正常存数据，辅助栈同步存当前的最小值。Push 时，如果新值 <= 辅助栈顶，则也入辅助栈。Pop 时，如果出栈值等于辅助栈顶，辅助栈也出栈。",
    timeComplexity: "O(1)",
    spaceComplexity: "O(n)",
    exampleInput: "push(-2), push(0), push(-3), getMin()",
    exampleOutput: "-3"
  },
  {
    id: 198,
    title: "House Robber",
    titleCn: "打家劫舍",
    slug: "house-robber",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "You cannot rob adjacent houses. Given amounts in each house, find max money you can rob.",
    descriptionCn: "你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。求最大金额。",
    solutionIdea: "DP. `dp[i]` = max money at house `i`. `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`. Rob current or skip current.",
    solutionIdeaCn: "动态规划。dp[i] 表示前 i 间房能偷到的最大金额。递推公式：dp[i] = max(dp[i-1], dp[i-2] + nums[i])。即：要么不偷第 i 间（保持 i-1 的结果），要么偷第 i 间（加上 i-2 的结果）。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [1,2,3,1]",
    exampleOutput: "4"
  },
  {
    id: 200,
    title: "Number of Islands",
    titleCn: "岛屿数量",
    slug: "number-of-islands",
    difficulty: Difficulty.Medium,
    tags: ["DFS", "BFS"],
    description: "Given an `m x n` 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.",
    descriptionCn: "给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。",
    solutionIdea: "Iterate grid. If '1' found, increment count and start DFS/BFS to mark all connected '1's as '0' (visited).",
    solutionIdeaCn: "DFS/BFS 沉岛法。遍历网格，遇到 '1' 时岛屿数加一，并启动 DFS 将当前陆地及其所有相连的陆地都置为 '0'（标记为已访问），避免重复计算。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(mn)",
    exampleInput: "grid = [[\"1\",\"1\",\"0\"],[\"1\",\"0\",\"0\"]]",
    exampleOutput: "2"
  },
  {
    id: 207,
    title: "Course Schedule",
    titleCn: "课程表",
    slug: "course-schedule",
    difficulty: Difficulty.Medium,
    tags: ["Graph", "Topological Sort"],
    description: "There are `numCourses` courses. You are given prerequisites. Return `true` if you can finish all courses (i.e., no cycle in dependency graph).",
    descriptionCn: "你这个学期必须选修 numCourses 门课程。在选修某些课程之前需要一些先修课程。请你判断是否可能完成所有课程的学习（检测有向图是否有环）。",
    solutionIdea: "Topological Sort (Kahn's Algo). Track indegrees. Queue stores nodes with 0 indegree. Pop node, decrement neighbors' indegree. If count == numCourses, valid.",
    solutionIdeaCn: "拓扑排序。统计每个节点的入度。将所有入度为 0 的节点入队。当队列非空时，出队节点，计数+1，并将其邻居节点入度减 1，若邻居入度变 0 则入队。最后判断出队数量是否等于课程总数。",
    timeComplexity: "O(V+E)",
    spaceComplexity: "O(V+E)",
    exampleInput: "num = 2, pre = [[1,0]]",
    exampleOutput: "true"
  },
  {
    id: 208,
    title: "Implement Trie",
    titleCn: "实现 Trie (前缀树)",
    slug: "implement-trie-prefix-tree",
    difficulty: Difficulty.Medium,
    tags: ["Design", "Trie"],
    description: "Implement a Trie (Prefix Tree) with `insert`, `search`, and `startsWith` methods.",
    descriptionCn: "Trie（发音类似 \"try\"）或前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。请实现 Trie 类。",
    solutionIdea: "Tree of nodes. Each node has array `children[26]` and boolean `isEnd`. `insert`: walk/create nodes. `search`: walk, check `isEnd`. `startsWith`: walk, return true if path exists.",
    solutionIdeaCn: "多叉树结构。每个节点包含一个大小为 26 的子节点指针数组和一个 isEnd 标记。插入时遍历字符，不存在则新建节点。查找时遍历字符，若中途为空则 false，最后检查 isEnd。",
    timeComplexity: "O(L)",
    spaceComplexity: "O(L)",
    exampleInput: "insert(\"apple\"), search(\"apple\")",
    exampleOutput: "true"
  },
  {
    id: 215,
    title: "Kth Largest Element",
    titleCn: "数组中的第K个最大元素",
    slug: "kth-largest-element-in-an-array",
    difficulty: Difficulty.Medium,
    tags: ["Heap", "Quickselect"],
    description: "Given an integer array `nums` and an integer `k`, return the `k`th largest element in the array.",
    descriptionCn: "给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。",
    solutionIdea: "Quickselect (Partition like QuickSort) for O(n) average. Or Min-Heap of size `k` for O(n log k). Heap stores top k elements, root is the kth largest.",
    solutionIdeaCn: "方法一：快速选择 (Quickselect)，基于快排 Partition 思想，平均时间 O(n)。方法二：维护一个容量为 k 的小顶堆，遍历数组，如果元素 > 堆顶则入堆并弹出堆顶。最后堆顶即为第 k 大。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [3,2,1,5,6,4], k = 2",
    exampleOutput: "5"
  },
  {
    id: 221,
    title: "Maximal Square",
    titleCn: "最大正方形",
    slug: "maximal-square",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Given an `m x n` binary matrix filled with 0s and 1s, find the largest square containing only 1s and return its area.",
    descriptionCn: "在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积。",
    solutionIdea: "DP. `dp[i][j]` = side length of largest square ending at (i,j). If `matrix[i][j] == '1'`, `dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`.",
    solutionIdeaCn: "动态规划。dp[i][j] 表示以 (i, j) 为右下角的最大正方形边长。若该位置是 1，则边长受限于左边、上边、左上边三个正方形边长的最小值加 1。Area = maxSide * maxSide。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(mn)",
    exampleInput: "matrix = [[\"1\",\"0\",\"1\",\"0\",\"0\"],[\"1\",\"0\",\"1\",\"1\",\"1\"],[\"1\",\"1\",\"1\",\"1\",\"1\"],[\"1\",\"0\",\"0\",\"1\",\"0\"]]",
    exampleOutput: "4"
  },
  {
    id: 236,
    title: "LCA of Binary Tree",
    titleCn: "二叉树的最近公共祖先",
    slug: "lowest-common-ancestor-of-a-binary-tree",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes `p` and `q`.",
    descriptionCn: "给定一个二叉树, 找到该树中两个指定节点 p 和 q 的最近公共祖先 (LCA)。",
    solutionIdea: "DFS. If root is null, p, or q, return root. Recurse left and right. If both return non-null, root is LCA. If one returns non-null, pass it up.",
    solutionIdeaCn: "递归后序遍历。如果当前节点为空、p 或 q，直接返回当前节点。递归查找左右子树。如果左右子树返回值都不为空，说明 p, q 分布在异侧，当前节点为 LCA。否则返回不为空的那一边。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [3,5,1...], p=5, q=1",
    exampleOutput: "3"
  },
  {
    id: 238,
    title: "Product of Array Except Self",
    titleCn: "除自身以外数组的乘积",
    slug: "product-of-array-except-self",
    difficulty: Difficulty.Medium,
    tags: ["Array"],
    description: "Return an array where `answer[i]` is product of all nums except `nums[i]`. O(n) time, no division allowed.",
    descriptionCn: "给你一个整数数组 nums，返回数组 answer，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。要求 O(n) 且不能使用除法。",
    solutionIdea: "Left and Right Arrays (or 1 pass optimization). `L[i]` = product of elements left of `i`. `R[i]` = product of elements right of `i`. `Ans[i] = L[i] * R[i]`.",
    solutionIdeaCn: "前缀积 * 后缀积。先遍历一遍计算每个位置左边所有数的乘积存入结果数组。再反向遍历，维护一个右边所有数的乘积变量，乘到结果数组对应位置。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [1,2,3,4]",
    exampleOutput: "[24,12,8,6]"
  },
  {
    id: 240,
    title: "Search a 2D Matrix II",
    titleCn: "搜索二维矩阵 II",
    slug: "search-a-2d-matrix-ii",
    difficulty: Difficulty.Medium,
    tags: ["Array", "Divide and Conquer"],
    description: "Search `target` in an `m x n` matrix where rows and columns are sorted in ascending order.",
    descriptionCn: "编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵每一行和每一列都是按升序排列的。",
    solutionIdea: "Start from Top-Right corner. If `curr > target`, move left (decrease). If `curr < target`, move down (increase). This eliminates a row or column each step.",
    solutionIdeaCn: "从右上角（或左下角）开始搜索。如果当前值 > target，向左移动（变小）；如果当前值 < target，向下移动（变大）。利用行列有序性逐步缩小范围。",
    timeComplexity: "O(m+n)",
    spaceComplexity: "O(1)",
    exampleInput: "matrix = [[1,4,7],[2,5,8]...], target = 5",
    exampleOutput: "true"
  },
  {
    id: 279,
    title: "Perfect Squares",
    titleCn: "完全平方数",
    slug: "perfect-squares",
    difficulty: Difficulty.Medium,
    tags: ["DP", "BFS"],
    description: "Given an integer `n`, return the least number of perfect square numbers that sum to `n`.",
    descriptionCn: "给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。",
    solutionIdea: "DP. `dp[i]` = min squares to sum to `i`. `dp[i] = min(dp[i - j*j]) + 1` for all valid `j`.",
    solutionIdeaCn: "动态规划。dp[i] 表示组成 i 的最少平方数个数。dp[i] = 1 + min(dp[i - j*j])，枚举所有可能的 j。这是一个完全背包问题变种。",
    timeComplexity: "O(n*sqrt(n))",
    spaceComplexity: "O(n)",
    exampleInput: "n = 12",
    exampleOutput: "3 (4+4+4)"
  },
  {
    id: 287,
    title: "Find the Duplicate Number",
    titleCn: "寻找重复数",
    slug: "find-the-duplicate-number",
    difficulty: Difficulty.Medium,
    tags: ["Array", "Two Pointers"],
    description: "Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]`, find the duplicate number.",
    descriptionCn: "给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。找出这个重复的数。",
    solutionIdea: "Floyd's Cycle Detection (Tortoise and Hare). Treat index -> value as a linked list pointer `i -> nums[i]`. Find entry point of the cycle.",
    solutionIdeaCn: "快慢指针判环。将数组视为链表：index 指向 nums[index]。因为有重复数，意味着有两个索引指向同一个值，形成环。先用快慢指针相遇，再找入环点。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [1,3,4,2,2]",
    exampleOutput: "2"
  },
  {
    id: 300,
    title: "Longest Increasing Subsequence",
    titleCn: "最长递增子序列",
    slug: "longest-increasing-subsequence",
    difficulty: Difficulty.Medium,
    tags: ["DP", "Binary Search"],
    description: "Given an integer array `nums`, return the length of the longest strictly increasing subsequence.",
    descriptionCn: "给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。",
    solutionIdea: "Patience Sorting (Greedy + Binary Search). Maintain a `tails` array where `tails[i]` is the smallest tail of all increasing subsequences of length `i+1`. Update `tails` using binary search.",
    solutionIdeaCn: "贪心 + 二分查找。维护一个 tails 数组，tails[k] 存储长度为 k+1 的所有递增子序列中，结尾最小的那个数。遍历数组，通过二分查找更新 tails，使其增长尽可能慢，从而变得更长。",
    timeComplexity: "O(n log n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [10,9,2,5,3,7,101,18]",
    exampleOutput: "4"
  },
  {
    id: 309,
    title: "Best Time to Buy and Sell Stock with Cooldown",
    titleCn: "最佳买卖股票时机含冷冻期",
    slug: "best-time-to-buy-and-sell-stock-with-cooldown",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "You may complete as many transactions as you like, but after you sell your stock, you cannot buy stock on the next day (cooldown one day).",
    descriptionCn: "卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。求最大利润。",
    solutionIdea: "State Machine DP. States: `Hold`, `Sold` (just sold), `Rest`. Transitions based on actions (buy, sell, wait).",
    solutionIdeaCn: "状态机 DP。三个状态：持有股票 (hold)，不持有且处于冷冻期 (sold)，不持有且不处于冷冻期 (rest)。hold由前一天hold或rest买入转移；sold由hold卖出转移；rest由前一天sold或rest转移。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "prices = [1,2,3,0,2]",
    exampleOutput: "3"
  },
  {
    id: 322,
    title: "Coin Change",
    titleCn: "零钱兑换",
    slug: "coin-change",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Given coins of different denominations and a total amount, return the fewest number of coins that you need to make up that amount.",
    descriptionCn: "给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。计算并返回可以凑成总金额所需的 最少的硬币个数 。",
    solutionIdea: "DP. `dp[i]` = min coins for amount `i`. `dp[i] = min(dp[i], dp[i-coin] + 1)`. Initialize `dp` with infinity, `dp[0]=0`.",
    solutionIdeaCn: "完全背包 DP。dp[i] 表示金额 i 所需最少硬币数。遍历金额 i 从 1 到 amount，再遍历硬币 coin，dp[i] = min(dp[i], dp[i-coin] + 1)。",
    timeComplexity: "O(Sn)",
    spaceComplexity: "O(S)",
    exampleInput: "coins = [1,2,5], amount = 11",
    exampleOutput: "3"
  },
  {
    id: 337,
    title: "House Robber III",
    titleCn: "打家劫舍 III",
    slug: "house-robber-iii",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DP"],
    description: "The thief has found himself a new place for his thievery again. There is only one entrance to this area, called the \"root\". Besides the root, each house has one and only one parent house. After a tour, the smart thief realized that \"all houses in this place form a binary tree\". It will automatically contact the police if two directly-linked houses were broken into on the same night.",
    descriptionCn: "小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。",
    solutionIdea: "Tree DP. Return a pair `[rob, not_rob]` for each node. `rob = val + left.not_rob + right.not_rob`. `not_rob = max(left) + max(right)`.",
    solutionIdeaCn: "树形 DP。每个节点返回两个值 [选当前节点的最大值, 不选当前节点的最大值]。选当前 = val + 左不选 + 右不选。不选当前 = max(左) + max(右)。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [3,2,3,null,3,null,1]",
    exampleOutput: "7"
  },
  {
    id: 347,
    title: "Top K Frequent Elements",
    titleCn: "前 K 个高频元素",
    slug: "top-k-frequent-elements",
    difficulty: Difficulty.Medium,
    tags: ["Heap"],
    description: "Given an integer array `nums` and an integer `k`, return the `k` most frequent elements.",
    descriptionCn: "给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。",
    solutionIdea: "Count frequencies with Map. Then use Min-Heap of size `k` to keep top elements, or Bucket Sort where index is frequency.",
    solutionIdeaCn: "哈希表统计频率。然后用最小堆维护频率最高的 k 个元素。或者使用桶排序，将频率作为数组下标，值为该频率对应的数字列表，从后往前取 k 个。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [1,1,1,2,2,3], k = 2",
    exampleOutput: "[1,2]"
  },
  {
    id: 394,
    title: "Decode String",
    titleCn: "字符串解码",
    slug: "decode-string",
    difficulty: Difficulty.Medium,
    tags: ["Stack"],
    description: "Given an encoded string, return its decoded string. The encoding rule is: `k[encoded_string]`, where the `encoded_string` inside the square brackets is being repeated exactly `k` times.",
    descriptionCn: "给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。",
    solutionIdea: "Two Stacks. `countStack` for numbers, `strStack` for strings. When `[`, push current count and string. When `]`, pop count and prev string, append repeated current string to prev.",
    solutionIdeaCn: "辅助栈。维护数字栈和字符串栈。遇到 '['，将当前倍数和当前字符串入栈，置空。遇到 ']'，弹出倍数 k 和上一层字符串，将当前字符串重复 k 次拼接到上一层字符串后。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \"3[a]2[bc]\"",
    exampleOutput: "\"aaabcbc\""
  },
  {
    id: 399,
    title: "Evaluate Division",
    titleCn: "除法求值",
    slug: "evaluate-division",
    difficulty: Difficulty.Medium,
    tags: ["Graph", "DFS", "Union Find"],
    description: "Given equations `A / B = k`, evaluate queries `C / D`. Return -1.0 if not possible.",
    descriptionCn: "给你一个变量对数组 equations 和一个实数值数组 values 作为已知条件，其中 equations[i] = [Ai, Bi] 和 values[i] 共同表示等式 Ai / Bi = values[i] 。请你对 queries 数组中的问题进行求值。",
    solutionIdea: "Graph Modeling. Variables are nodes. `a/b = k` is edge `a->b` weight `k`, `b->a` weight `1/k`. Use DFS/BFS to find path product from start to end.",
    solutionIdeaCn: "图论建图。将变量看作节点，除法关系看作有向带权边。a/b=k 即 a->b 权值 k，b->a 权值 1/k。对于查询 x/y，即寻找从 x 到 y 的路径，路径权值乘积即为结果。",
    timeComplexity: "O(E+Q*V)",
    spaceComplexity: "O(V)",
    exampleInput: "calc a/c given a/b, b/c",
    exampleOutput: "..."
  },
  {
    id: 406,
    title: "Queue Reconstruction by Height",
    titleCn: "根据身高重建队列",
    slug: "queue-reconstruction-by-height",
    difficulty: Difficulty.Medium,
    tags: ["Greedy"],
    description: "Reconstruct the queue. Each person is `[h, k]`, where `h` is height and `k` is the number of people in front with height `>= h`.",
    descriptionCn: "假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。",
    solutionIdea: "Sort + Insert. Sort by height descending. If heights equal, sort by `k` ascending. Then insert each person into the result list at index `k`.",
    solutionIdeaCn: "先排序再插入。按身高 h 降序排序，若 h 相同则按 k 升序。然后遍历数组，根据 k 值将人插入到结果列表的 index = k 处。高个子先站好，矮个子插进去不会影响高个子的 k 值。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(n)",
    exampleInput: "[[7,0],[4,4],[7,1]...]",
    exampleOutput: "[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]"
  },
  {
    id: 416,
    title: "Partition Equal Subset Sum",
    titleCn: "分割等和子集",
    slug: "partition-equal-subset-sum",
    difficulty: Difficulty.Medium,
    tags: ["DP"],
    description: "Given a non-empty array `nums`, return `true` if you can partition it into two subsets with equal sum.",
    descriptionCn: "给你一个只包含正整数的非空数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。",
    solutionIdea: "0/1 Knapsack. Target is `sum(nums) / 2`. Can we pick numbers to sum to target? `dp[i]` = boolean reachable sum.",
    solutionIdeaCn: "0-1 背包问题。目标是找到子集和等于 sum/2。dp[j] 表示容量为 j 的背包能否被填满。dp[j] = dp[j] || dp[j - num]。",
    timeComplexity: "O(n*S)",
    spaceComplexity: "O(S)",
    exampleInput: "nums = [1,5,11,5]",
    exampleOutput: "true"
  },
  {
    id: 437,
    title: "Path Sum III",
    titleCn: "路径总和 III",
    slug: "path-sum-iii",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Given the root of a binary tree and an integer `targetSum`, return the number of paths where the sum of the values along the path equals `targetSum`. The path does not need to start or end at the root or a leaf, but it must go downwards.",
    descriptionCn: "给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 路径 的数目。路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。",
    solutionIdea: "Prefix Sum + DFS. Keep a map of `prefix_sum` counts. For curr node, check if `curr_sum - target` exists in map. Add `curr_sum` to map, recurse, then remove (backtrack).",
    solutionIdeaCn: "前缀和 + 回溯。维护一个 Map 记录从根到当前路径上各种前缀和出现的次数。对于当前节点的前缀和 currSum，查找 Map 中 currSum - target 的个数，累加到结果。注意回溯时要将当前前缀和计数减一。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [10,5,-3...], target = 8",
    exampleOutput: "3"
  },
  {
    id: 438,
    title: "Find All Anagrams",
    titleCn: "找到字符串中所有字母异位词",
    slug: "find-all-anagrams-in-a-string",
    difficulty: Difficulty.Medium,
    tags: ["Sliding Window"],
    description: "Given two strings `s` and `p`, return an array of all the start indices of `p`'s anagrams in `s`.",
    descriptionCn: "给定两个字符串 s 和 p，找到 s 中所有是 p 的 字母异位词 的子串，返回这些子串的起始索引。",
    solutionIdea: "Sliding Window. Maintain a window of length `p.length`. Compare character counts of window vs `p`. Slide window right, update counts.",
    solutionIdeaCn: "固定长度滑动窗口。窗口大小为 p 的长度。维护窗口内的字符计数数组，与 p 的计数数组比较。每次右移一格，更新进出字符的计数。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"cbaebabacd\", p = \"abc\"",
    exampleOutput: "[0,6]"
  },
  {
    id: 494,
    title: "Target Sum",
    titleCn: "目标和",
    slug: "target-sum",
    difficulty: Difficulty.Medium,
    tags: ["DP", "DFS"],
    description: "You have integers `nums` and target. For each num, assign '+' or '-'. Count ways to make sum equal to target.",
    descriptionCn: "给你一个整数数组 nums 和一个整数 target 。向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 。求结果等于 target 的不同表达式的数目。",
    solutionIdea: "DP / Subset Sum. Let P be positive subset, N be negative. `P - N = target`, `P + N = sum`. So `2P = target + sum`. Find subset sum P.",
    solutionIdeaCn: "转化为子集和问题。设 P 为正数集，N 为负数集。P - N = target，且 P + N = sum。推导出 P = (sum + target) / 2。问题变为：在数组中找子集和为 P 的方案数。",
    timeComplexity: "O(n*S)",
    spaceComplexity: "O(S)",
    exampleInput: "nums = [1,1,1,1,1], target = 3",
    exampleOutput: "5"
  },
  {
    id: 538,
    title: "Convert BST to Greater Tree",
    titleCn: "把二叉搜索树转换为累加树",
    slug: "convert-bst-to-greater-tree",
    difficulty: Difficulty.Medium,
    tags: ["Tree", "DFS"],
    description: "Convert a BST such that every key is changed to the original key plus the sum of all keys greater than the original key in BST.",
    descriptionCn: "给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。",
    solutionIdea: "Reverse Inorder Traversal (Right -> Root -> Left). Keep a running `sum`. `node.val += sum`; `sum = node.val`.",
    solutionIdeaCn: "反向中序遍历。顺序为：右子树 -> 根 -> 左子树。维护一个全局累加和 sum，每次访问节点时，将 sum 加到节点值上，并更新 sum。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [4,1,6...]",
    exampleOutput: "[30,36,21...]"
  },
  {
    id: 560,
    title: "Subarray Sum Equals K",
    titleCn: "和为 K 的子数组",
    slug: "subarray-sum-equals-k",
    difficulty: Difficulty.Medium,
    tags: ["Prefix Sum"],
    description: "Given an array of integers `nums` and an integer `k`, return the total number of continuous subarrays whose sum equals to `k`.",
    descriptionCn: "给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。",
    solutionIdea: "Prefix Sum + Hash Map. `sum[i...j] = prefix[j] - prefix[i-1] == k`. So `prefix[i-1] = prefix[j] - k`. Iterate storing prefix sums in map, check count of `curr - k`.",
    solutionIdeaCn: "前缀和 + 哈希表。遍历数组计算前缀和 sum。如果 sum - k 在哈希表中出现过，说明存在中间一段子数组和为 k。累加次数，并将当前 sum 存入哈希表。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "nums = [1,1,1], k = 2",
    exampleOutput: "2"
  },
  {
    id: 581,
    title: "Shortest Unsorted Continuous Subarray",
    titleCn: "最短无序连续子数组",
    slug: "shortest-unsorted-continuous-subarray",
    difficulty: Difficulty.Medium,
    tags: ["Array"],
    description: "Given an integer array `nums`, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and output its length.",
    descriptionCn: "给你一个整数数组 nums ，你需要找出一个 连续子数组 ，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。请你找出符合题意的 最短 子数组，并输出它的长度。",
    solutionIdea: "Two passes. L->R: find right limit (last element less than running max). R->L: find left limit (last element greater than running min).",
    solutionIdeaCn: "双指针/四次遍历。从左到右维护 max，如果当前值 < max，说明该位置需要排序，更新右边界。从右到左维护 min，如果当前值 > min，更新左边界。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "nums = [2,6,4,8,10,9,15]",
    exampleOutput: "5"
  },
  {
    id: 621,
    title: "Task Scheduler",
    titleCn: "任务调度器",
    slug: "task-scheduler",
    difficulty: Difficulty.Medium,
    tags: ["Greedy"],
    description: "Given tasks and a cooling interval `n`, return the least number of units of time to finish all tasks.",
    descriptionCn: "给你一个用字符数组 tasks 表示的 CPU 需要执行的任务列表。其中 of 每个字母表示一种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。在任何一个单位时间，CPU 可以完成一个任务，或者处于待命状态。两个 相同种类 的任务之间必须有长度为整数 n 的冷却时间。计算完成所有任务所需要的最短时间。",
    solutionIdea: "Greedy/Math. The most frequent task determines the frame. `(max_count - 1) * (n + 1) + number_of_max_tasks`. Result is `max(tasks.length, calculated_val)`.",
    solutionIdeaCn: "填桶法。找出出现次数最多的任务 maxFreq。至少需要 (maxFreq - 1) * (n + 1) 个时间槽，再加上最后一行同为 maxFreq 的任务个数。结果取该计算值与任务总长度的较大值。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2",
    exampleOutput: "8"
  },
  {
    id: 647,
    title: "Palindromic Substrings",
    titleCn: "回文子串",
    slug: "palindromic-substrings",
    difficulty: Difficulty.Medium,
    tags: ["String", "DP"],
    description: "Given a string `s`, return the number of palindromic substrings in it.",
    descriptionCn: "给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。",
    solutionIdea: "Expand Around Center. Iterate through each character (and gap) as center. Expand while palindrome, increment count.",
    solutionIdeaCn: "中心扩散法。遍历每个字符和间隙作为中心，向两边扩散。只要是回文串，计数器加 1。共有 2n-1 个中心。",
    timeComplexity: "O(n^2)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"abc\"",
    exampleOutput: "3"
  },
  {
    id: 739,
    title: "Daily Temperatures",
    titleCn: "每日温度",
    slug: "daily-temperatures",
    difficulty: Difficulty.Medium,
    tags: ["Stack"],
    description: "Given an array of temperatures, return an array `answer` such that `answer[i]` is the number of days you have to wait after the `i`th day to get a warmer temperature.",
    descriptionCn: "给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果之后没有更高温度，则为 0。",
    solutionIdea: "Monotonic Decreasing Stack. Store indices. If current temp > stack top temp, pop stack and calculate distance `curr_index - pop_index`.",
    solutionIdeaCn: "单调递减栈。栈存储索引。遍历温度，如果当前温度 > 栈顶索引对应的温度，说明找到了升温日。弹出栈顶，计算下标差值即为天数。将当前索引入栈。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "temps = [73,74,75...]",
    exampleOutput: "[1,1,4...]"
  },

  // --- HARD ---
  {
    id: 4,
    title: "Median of Two Sorted Arrays",
    titleCn: "寻找两个正序数组的中位数",
    slug: "median-of-two-sorted-arrays",
    difficulty: Difficulty.Hard,
    tags: ["Binary Search"],
    description: "Given two sorted arrays `nums1` and `nums2` of size `m` and `n`, return the median of the two sorted arrays. Time complexity should be `O(log (m+n))`.",
    descriptionCn: "给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。算法的时间复杂度应该为 O(log (m+n)) 。",
    solutionIdea: "Binary Search on Partition. Partition both arrays such that left halves have same size as right halves. Ensure `maxLeft <= minRight`. Search on the smaller array's cut position.",
    solutionIdeaCn: "对较短数组进行二分查找切分点 i，长数组切分点 j 自动确定。满足 nums1[i-1] <= nums2[j] 且 nums2[j-1] <= nums1[i]。找到后根据 maxLeft 和 minRight 计算中位数。",
    timeComplexity: "O(log min(m,n))",
    spaceComplexity: "O(1)",
    exampleInput: "nums1 = [1,3], nums2 = [2]",
    exampleOutput: "2.0"
  },
  {
    id: 10,
    title: "Regular Expression Matching",
    titleCn: "正则表达式匹配",
    slug: "regular-expression-matching",
    difficulty: Difficulty.Hard,
    tags: ["DP", "Recursion"],
    description: "Implement regex matching with support for `.` (any char) and `*` (zero or more of preceding). Matching covers entire string.",
    descriptionCn: "给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。'.' 匹配任意单个字符，'*' 匹配零个或多个前面的那一个元素。所谓匹配，是要覆盖 整个 字符串 s的。",
    solutionIdea: "DP. `dp[i][j]` means `s[:i]` matches `p[:j]`. If `p[j]` is char/., check match. If `*`, check `dp[i][j-2]` (0 occurrence) or `match && dp[i-1][j]` (1+ occurrences).",
    solutionIdeaCn: "动态规划。dp[i][j] 表示 s 的前 i 个和 p 的前 j 个是否匹配。重点处理 '*'：它可以让前一个字符出现 0 次（看 dp[i][j-2]）或多次（当前字符匹配且看 dp[i-1][j]）。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(mn)",
    exampleInput: "s = \"aa\", p = \"a*\"",
    exampleOutput: "true"
  },
  {
    id: 23,
    title: "Merge k Sorted Lists",
    titleCn: "合并 K 个升序链表",
    slug: "merge-k-sorted-lists",
    difficulty: Difficulty.Hard,
    tags: ["Heap"],
    description: "You are given an array of `k` linked-lists lists, each linked-list is sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.",
    descriptionCn: "给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。",
    solutionIdea: "Min-Heap (Priority Queue). Push head of all `k` lists to heap. Pop min node, attach to result, push `node.next` to heap. Repeat.",
    solutionIdeaCn: "优先队列（最小堆）。将 k 个链表的头节点加入堆中。每次弹出最小节点接在结果链表后，如果该节点有 next，将 next 入堆。",
    timeComplexity: "O(N log k)",
    spaceComplexity: "O(k)",
    exampleInput: "lists = [[1,4,5],[1,3,4],[2,6]]",
    exampleOutput: "[1,1,2,3,4,4,5,6]"
  },
  {
    id: 32,
    title: "Longest Valid Parentheses",
    titleCn: "最长有效括号",
    slug: "longest-valid-parentheses",
    difficulty: Difficulty.Hard,
    tags: ["Stack", "DP"],
    description: "Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses substring.",
    descriptionCn: "给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。",
    solutionIdea: "Stack. Push -1 initially. For '(', push index. For ')', pop. If stack empty, push current index (new base). Else `max = max(max, i - stack.top)`.",
    solutionIdeaCn: "栈。栈底保留“上一个无效的右括号索引”（初始为 -1）。遇左括号入栈索引；遇右括号出栈。若栈空，压入当前索引作为新起点；若不空，更新 max = 当前索引 - 栈顶索引。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \")()())\"",
    exampleOutput: "4"
  },
  {
    id: 42,
    title: "Trapping Rain Water",
    titleCn: "接雨水",
    slug: "trapping-rain-water",
    difficulty: Difficulty.Hard,
    tags: ["Two Pointers"],
    description: "Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.",
    descriptionCn: "给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。",
    solutionIdea: "Two Pointers. `left`, `right`. Maintain `leftMax`, `rightMax`. If `leftMax < rightMax`, fill left side (water = `leftMax - height[left]`), move left. Else fill right.",
    solutionIdeaCn: "双指针。维护左右两边最大高度 leftMax 和 rightMax。如果 leftMax < rightMax，说明左边积水高度受限于 leftMax，处理左指针并右移；否则处理右指针并左移。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "height = [0,1,0,2,1...]",
    exampleOutput: "6"
  },
  {
    id: 72,
    title: "Edit Distance",
    titleCn: "编辑距离",
    slug: "edit-distance",
    difficulty: Difficulty.Hard,
    tags: ["DP"],
    description: "Given two strings `word1` and `word2`, return the minimum number of operations required to convert `word1` to `word2`. Ops: Insert, Delete, Replace.",
    descriptionCn: "给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。你可以进行插入、删除、替换字符操作。",
    solutionIdea: "DP. `dp[i][j]` = dist between `w1[:i]` and `w2[:j]`. If chars equal, `dp[i-1][j-1]`. Else `1 + min(insert, delete, replace)`.",
    solutionIdeaCn: "动态规划。dp[i][j] 表示 word1 前 i 字符变到 word2 前 j 字符的操作数。若字符相等则沿用 dp[i-1][j-1]；否则取增、删、改三者的最小值 + 1。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(mn)",
    exampleInput: "word1 = \"horse\", word2 = \"ros\"",
    exampleOutput: "3"
  },
  {
    id: 76,
    title: "Minimum Window Substring",
    titleCn: "最小覆盖子串",
    slug: "minimum-window-substring",
    difficulty: Difficulty.Hard,
    tags: ["Sliding Window"],
    description: "Given two strings `s` and `t`, return the minimum window substring of `s` such that every character in `t` (including duplicates) is included in the window.",
    descriptionCn: "给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。",
    solutionIdea: "Sliding Window. Expand `right` until valid. Then shrink `left` while valid to find min length. Use map/array for char counts.",
    solutionIdeaCn: "滑动窗口。右指针扩展直到窗口包含 t 中所有字符。然后左指针收缩，尝试缩小窗口长度，直到不再满足条件。过程中记录最小长度。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(1)",
    exampleInput: "s = \"ADOBECODEBANC\", t = \"ABC\"",
    exampleOutput: "\"BANC\""
  },
  {
    id: 84,
    title: "Largest Rectangle in Histogram",
    titleCn: "柱状图中最大的矩形",
    slug: "largest-rectangle-in-histogram",
    difficulty: Difficulty.Hard,
    tags: ["Stack"],
    description: "Given an array of integers `heights` representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.",
    descriptionCn: "给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。",
    solutionIdea: "Monotonic Increasing Stack. Store indices. If curr height < stack top height, pop top. Area = `top_height * (i - stack.peek() - 1)`. Use dummy 0 at ends.",
    solutionIdeaCn: "单调递增栈。遍历高度，如果当前高度小于栈顶，说明栈顶高度的右边界确定了。弹出栈顶，计算以该高度为矩形高度的面积：宽度 = 当前索引 - 新栈顶索引 - 1。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "heights = [2,1,5,6,2,3]",
    exampleOutput: "10"
  },
  {
    id: 85,
    title: "Maximal Rectangle",
    titleCn: "最大矩形",
    slug: "maximal-rectangle",
    difficulty: Difficulty.Hard,
    tags: ["Stack", "DP"],
    description: "Given a `rows x cols` binary matrix filled with 0s and 1s, find the largest rectangle containing only 1s and return its area.",
    descriptionCn: "给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。",
    solutionIdea: "Convert to Histogram. For each row, update heights (if '1', h++, else h=0). Calculate max rectangle for current row's histogram (Problem 84).",
    solutionIdeaCn: "转化为柱状图问题。遍历每一行，以该行为底边，计算每个位置向上的连续 '1' 的高度。然后对每一行的高度数组调用“柱状图最大矩形”的算法，取最大值。",
    timeComplexity: "O(mn)",
    spaceComplexity: "O(n)",
    exampleInput: "matrix = [[\"1\",\"0\"...]]",
    exampleOutput: "6"
  },
  {
    id: 124,
    title: "Binary Tree Maximum Path Sum",
    titleCn: "二叉树中的最大路径和",
    slug: "binary-tree-maximum-path-sum",
    difficulty: Difficulty.Hard,
    tags: ["Tree", "DFS"],
    description: "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge. The path sum is the sum of the nodes' values. Find the maximum path sum (any node to any node).",
    descriptionCn: "路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。求最大路径和。",
    solutionIdea: "Recursion. For each node, compute max gain from left and right subtrees (ignore negative gains). Update global max with `node.val + left + right`. Return `node.val + max(left, right)` to parent.",
    solutionIdeaCn: "递归。函数返回“从当前节点向下走的最大单边路径和”。在递归过程中，计算经过当前节点的最大路径和（left + right + node.val）并更新全局最大值。返回给父节点的是 node.val + max(left, right, 0)。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [-10,9,20,15,7]",
    exampleOutput: "42"
  },
  {
    id: 239,
    title: "Sliding Window Maximum",
    titleCn: "滑动窗口最大值",
    slug: "sliding-window-maximum",
    difficulty: Difficulty.Hard,
    tags: ["Queue"],
    description: "You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. Return the max sliding window.",
    descriptionCn: "给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。返回滑动窗口中的最大值。",
    solutionIdea: "Monotonic Deque (Decreasing). Deque stores indices. Remove old indices out of window. Remove indices from back if `nums[back] < curr`. Add curr. Front is max.",
    solutionIdeaCn: "单调双端队列（递减）。队列存下标。移动窗口时：1. 队头过期下标出队。2. 队尾所有小于当前值的下标出队（它们不可能是最大值了）。3. 当前下标入队。4. 队头即为当前窗口最大值。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(k)",
    exampleInput: "nums = [1,3,-1,-3,5,3,6,7], k = 3",
    exampleOutput: "[3,3,5,5,6,7]"
  },
  {
    id: 297,
    title: "Serialize and Deserialize Binary Tree",
    titleCn: "二叉树的序列化与反序列化",
    slug: "serialize-and-deserialize-binary-tree",
    difficulty: Difficulty.Hard,
    tags: ["Tree", "DFS", "BFS"],
    description: "Design an algorithm to serialize and deserialize a binary tree. Converting tree to string and string back to tree.",
    descriptionCn: "序列化是将一个数据结构或者对象转换为连续的比特位的过程，进而可以存储在文件或内存缓冲器中，通过网络传输。请设计一个算法来实现二叉树的序列化与反序列化。",
    solutionIdea: "DFS Preorder or BFS Level Order. Use special char (e.g., '#') for null. DFS: `root,left,right`. BFS: `root, left, right` in queue order.",
    solutionIdeaCn: "前序遍历 (DFS)。序列化：递归 `val, left, right`，空节点存为 '#'。反序列化：按逗号分割，使用队列（或迭代器），递归构建：取第一个值为根，递归构建左，递归构建右。",
    timeComplexity: "O(n)",
    spaceComplexity: "O(n)",
    exampleInput: "root = [1,2,3]",
    exampleOutput: "Tree object"
  },
  {
    id: 301,
    title: "Remove Invalid Parentheses",
    titleCn: "删除无效的括号",
    slug: "remove-invalid-parentheses",
    difficulty: Difficulty.Hard,
    tags: ["BFS", "Backtracking"],
    description: "Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return all the possible results.",
    descriptionCn: "给你一个由若干括号和字母组成的字符串 s ，删除最小数量的无效括号，使得输入的字符串有效。返回所有可能的结果。",
    solutionIdea: "BFS. Level 0: original string. Level 1: remove 1 char. Check validity at each level. If valid found, stop generating next levels.",
    solutionIdeaCn: "BFS 广度优先搜索。第一层是原字符串。下一层是删除了一个字符的所有可能字符串。一旦在某一层找到了有效字符串，就加入结果集，并且不再扩展下一层（保证删除最少）。",
    timeComplexity: "O(2^n)",
    spaceComplexity: "O(n)",
    exampleInput: "s = \"()())()\"",
    exampleOutput: "[\"(())()\",\"()()()\"]"
  },
  {
    id: 312,
    title: "Burst Balloons",
    titleCn: "戳气球",
    slug: "burst-balloons",
    difficulty: Difficulty.Hard,
    tags: ["DP"],
    description: "Given `n` balloons with coins, burst them. Coins = `nums[i-1] * nums[i] * nums[i+1]`. Find max coins. Boundaries are 1.",
    descriptionCn: "有 n 个气球，编号为 0 到 n-1，每个气球上都标有一个数字，这些数字存在数组 nums 中。戳破气球 i 可以获得 nums[i-1] * nums[i] * nums[i+1] 枚硬币。求所能获得硬币的最大数量。",
    solutionIdea: "Interval DP. Reverse thinking: determine which balloon is burst LAST in range `(i, j)`. `dp[i][j] = max(dp[i][k] + dp[k][j] + nums[i]*nums[k]*nums[j])`.",
    solutionIdeaCn: "区间 DP。逆向思维：不是决定先戳哪个，而是枚举在这个区间 (i, j) 内 最后一个 被戳破的气球 k。状态转移：dp[i][j] = max(dp[i][k] + dp[k][j] + val[i]*val[k]*val[j])。",
    timeComplexity: "O(n^3)",
    spaceComplexity: "O(n^2)",
    exampleInput: "nums = [3,1,5,8]",
    exampleOutput: "167"
  }
];

export const STORAGE_KEY = 'leetcode-flash-v6';
